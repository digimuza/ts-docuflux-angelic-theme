{
	"docs": [
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Determines whether all predicates returns true for the input data.",
						"example": "const isDivisibleBy3 = (x: number) => x % 3 === 0\nconst isDivisibleBy4 = (x: number) => x % 4 === 0\nconst fns = [isDivisibleBy3, isDivisibleBy4]\nP.allPass(12, fns) // => true\nP.allPass(8, fns) // => false",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The input data for predicates.",
									"name": "data"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The list of predicates.",
									"name": "fns"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.allPass(data",
									"fns)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.allPass(fns)(data)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function allPass<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ", fns: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<(data: T) => boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!allPass:function(1)",
					"canonicalReferenceGroup": "ts-prime!allPass"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function allPass<T>(fns: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<(data: T) => boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(data: T) => boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!allPass:function(2)",
					"canonicalReferenceGroup": "ts-prime!allPass"
				}
			],
			"kind": "Function",
			"name": "allPass",
			"canonicalReference": "ts-prime!allPass:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!allPass",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Determines whether any predicate returns true for the input data.",
						"example": "const isDivisibleBy3 = (x: number) => x % 3 === 0\nconst isDivisibleBy4 = (x: number) => x % 4 === 0\nconst fns = [isDivisibleBy3, isDivisibleBy4]\nP.anyPass(fns)(8) // => true\nP.anyPass(fns)(11) // => false",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "item",
									"name": "data"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The list of predicates.",
									"name": "fns"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.anyPass(data",
									"fns)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.anyPass(fns)(data)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function anyPass<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ", fns: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<(data: T) => boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!anyPass:function(1)",
					"canonicalReferenceGroup": "ts-prime!anyPass"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function anyPass<T>(fns: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<(data: T) => boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(data: T) => boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!anyPass:function(2)",
					"canonicalReferenceGroup": "ts-prime!anyPass"
				}
			],
			"kind": "Function",
			"name": "anyPass",
			"canonicalReference": "ts-prime!anyPass:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!anyPass",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type ArgsType<T> = "
						},
						{
							"kind": "Content",
							"text": "T extends (...args: infer U) => any ? U : []"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!ArgsType:type",
					"canonicalReferenceGroup": "ts-prime!ArgsType"
				}
			],
			"kind": "TypeAlias",
			"name": "ArgsType",
			"canonicalReference": "ts-prime!ArgsType:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!ArgsType",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Assertion statement",
						"parsed": [
							{
								"tag": "@throws",
								"content": [
									"Throws if data is instance of error"
								]
							},
							{
								"tag": "@export",
								"content": [
									"const request = () =>  P.canFail(()=> axios.get(url))",
									"const result = await request.then(P.assertError)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function assertError<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T | "
						},
						{
							"kind": "Reference",
							"text": "Error",
							"canonicalReference": "!Error:interface"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!assertError:function(1)",
					"canonicalReferenceGroup": "ts-prime!assertError"
				}
			],
			"kind": "Function",
			"name": "assertError",
			"canonicalReference": "ts-prime!assertError:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!assertError",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Decode base64 encoded string.",
						"example": "P.base64decode(\"dHMtcHJpbWUgaXMgYXdlc29tZQ==\") //=> ts-prime is awesome",
						"parsed": [
							{
								"tag": "@signature",
								"content": [
									"P.base64decode(str)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function base64decode(input: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!base64decode:function(1)",
					"canonicalReferenceGroup": "ts-prime!base64decode"
				}
			],
			"kind": "Function",
			"name": "base64decode",
			"canonicalReference": "ts-prime!base64decode:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!base64decode",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"example": "P.base64encode(\"ts-prime is awesome\") //=> dHMtcHJpbWUgaXMgYXdlc29tZQ==",
						"parsed": [
							{
								"tag": "@documentation",
								"content": [
									"true"
								]
							},
							{
								"tag": "@sectionName",
								"content": [
									"Base64",
									"/*",
									"Encode string with base64 encoding."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.base64encode(str)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function base64encode(input: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!base64encode:function(1)",
					"canonicalReferenceGroup": "ts-prime!base64encode"
				}
			],
			"kind": "Function",
			"name": "base64encode",
			"canonicalReference": "ts-prime!base64encode:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!base64encode",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Function middleware that caches function output based on input",
						"example": "const request = (url: string) => axios.get(url)\nconst requestWithCache = P.cache(request, (url) => url)",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "target function",
									"name": "fn"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "function that receives and return cache key",
									"name": "cacheFn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.cache(fn",
									"options)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.cache(options)(fn)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function cache<I extends "
						},
						{
							"kind": "Content",
							"text": "(...args: any[]) => any"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "I"
						},
						{
							"kind": "Content",
							"text": ", options?: "
						},
						{
							"kind": "Reference",
							"text": "CacheOptions",
							"canonicalReference": "ts-prime!CacheOptions:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "ArgsType",
							"canonicalReference": "ts-prime!ArgsType:type"
						},
						{
							"kind": "Content",
							"text": "<I>, "
						},
						{
							"kind": "Reference",
							"text": "ReturnType",
							"canonicalReference": "!ReturnType:type"
						},
						{
							"kind": "Content",
							"text": "<I>>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "I"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!cache:function(1)",
					"canonicalReferenceGroup": "ts-prime!cache"
				}
			],
			"kind": "Function",
			"name": "cache",
			"canonicalReference": "ts-prime!cache:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!cache",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Interface",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export interface CacheMechanism<R> "
						}
					],
					"canonicalReference": "ts-prime!CacheMechanism:interface",
					"canonicalReferenceGroup": "ts-prime!CacheMechanism"
				}
			],
			"kind": "Interface",
			"name": "CacheMechanism",
			"canonicalReference": "ts-prime!CacheMechanism:interface",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!CacheMechanism",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Interface",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export interface CacheOptions<I extends "
						},
						{
							"kind": "Content",
							"text": "any[]"
						},
						{
							"kind": "Content",
							"text": ", R> "
						}
					],
					"canonicalReference": "ts-prime!CacheOptions:interface",
					"canonicalReferenceGroup": "ts-prime!CacheOptions"
				}
			],
			"kind": "Interface",
			"name": "CacheOptions",
			"canonicalReference": "ts-prime!CacheOptions:interface",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!CacheOptions",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Similar to try catch statement. If function throws insisted callback this function will return `Error` instance",
						"example": "const err = P.canFail(()=> JSON.parse(data))\nif (P.isError(err)) {\nconsole.log(err)\n}\nconst request = await canFail(() => axios.get(url))\nif (P.isError(request)) return",
						"parsed": [
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function canFail<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "() => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "CanGetError",
							"canonicalReference": "ts-prime!CanGetError:type"
						},
						{
							"kind": "Content",
							"text": "<T>>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!canFail:function(1)",
					"canonicalReferenceGroup": "ts-prime!canFail"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function canFail<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "() => T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "CanGetError",
							"canonicalReference": "ts-prime!CanGetError:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!canFail:function(2)",
					"canonicalReferenceGroup": "ts-prime!canFail"
				}
			],
			"kind": "Function",
			"name": "canFail",
			"canonicalReference": "ts-prime!canFail:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!canFail",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type CanGetError<T> = "
						},
						{
							"kind": "Reference",
							"text": "Error",
							"canonicalReference": "!Error:interface"
						},
						{
							"kind": "Content",
							"text": " | T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!CanGetError:type",
					"canonicalReferenceGroup": "ts-prime!CanGetError"
				}
			],
			"kind": "TypeAlias",
			"name": "CanGetError",
			"canonicalReference": "ts-prime!CanGetError:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!CanGetError",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Capitalize first letter of word",
						"example": "P.capitalize(\"tom\") //=> Tom",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Any string",
									"name": "str"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.capitalize(str)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"String"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function capitalize(str: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!capitalize:function(1)",
					"canonicalReferenceGroup": "ts-prime!capitalize"
				}
			],
			"kind": "Function",
			"name": "capitalize",
			"canonicalReference": "ts-prime!capitalize:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!capitalize",
			"tags": [
				{
					"tag": "@category",
					"value": "String"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Split an array into groups the length of `size`. If `array` can't be split evenly, the final chunk will be the remaining elements.",
						"example": "P.chunk(['a', 'b', 'c', 'd'], 2) // => [['a', 'b'], ['c', 'd']]\nP.chunk(['a', 'b', 'c', 'd'], 3) // => [['a', 'b', 'c'], ['d']]\nP.chunk(2)(['a', 'b', 'c', 'd']) // => [['a', 'b'], ['c', 'd']]\nP.chunk(3)(['a', 'b', 'c', 'd']) // => [['a', 'b', 'c'], ['d']]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the length of the chunk",
									"name": "size"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.chunk(array",
									"size)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.chunk(size)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function chunk<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", size: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "readonly T[][]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!chunk:function(1)",
					"canonicalReferenceGroup": "ts-prime!chunk"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function chunk<T>(size: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => readonly T[][]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!chunk:function(2)",
					"canonicalReferenceGroup": "ts-prime!chunk"
				}
			],
			"kind": "Function",
			"name": "chunk",
			"canonicalReference": "ts-prime!chunk:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!chunk",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Clamp the given value within the inclusive min and max bounds.",
						"example": "P.clamp(10, { min: 20 }) // => 20\nP.clamp(10, { max: 5 }) // => 5\nP.clamp(10, { max: 20, min: 5 }) // => 10\nP.clamp({ min: 20 })(10) // => 20\nP.clamp({ max: 5 })(10) // => 5\nP.clamp({ max: 20, min: 5 })(10) // => 10",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the number",
									"name": "value"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the bounds limits",
									"name": "limits"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.clamp(value",
									"{ min",
									"max });"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.clamp({ min",
									"max })(value);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Number",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function clamp(value: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ", limits: "
						},
						{
							"kind": "Content",
							"text": "{\n    min?: number;\n    max?: number;\n}"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!clamp:function(1)",
					"canonicalReferenceGroup": "ts-prime!clamp"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Clamp the given value within the inclusive min and max bounds.",
						"example": "P.clamp(10, { min: 20 }) // => 20\nP.clamp(10, { max: 5 }) // => 5\nP.clamp(10, { max: 20, min: 5 }) // => 10\nP.clamp({ min: 20 })(10) // => 20\nP.clamp({ max: 5 })(10) // => 5\nP.clamp({ max: 20, min: 5 })(10) // => 10",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the number",
									"name": "value"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the bounds limits",
									"name": "limits"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.clamp(value",
									"{ min",
									"max });"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.clamp({ min",
									"max })(value);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Number",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function clamp(limits: "
						},
						{
							"kind": "Content",
							"text": "{\n    min?: number;\n    max?: number;\n}"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: number) => number"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!clamp:function(2)",
					"canonicalReferenceGroup": "ts-prime!clamp"
				}
			],
			"kind": "Function",
			"name": "clamp",
			"canonicalReference": "ts-prime!clamp:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!clamp",
			"tags": [
				{
					"tag": "@category",
					"value": "Number"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Creates a deep copy of the value. Supported types: `Array`, `Object`, `Number`, `String`, `Boolean`, `Date`, `RegExp`. Functions are assigned by reference rather than copied.",
						"example": "P.clone({foo: 'bar'}) // {foo: 'bar'}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the object to clone",
									"name": "value"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.clone(value)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function clone<T extends "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": ">(value: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!clone:function(1)",
					"canonicalReferenceGroup": "ts-prime!clone"
				}
			],
			"kind": "Function",
			"name": "clone",
			"canonicalReference": "ts-prime!clone:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!clone",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Removes all undefined and null values from object rreecursively",
						"example": "P.compact({foo: undefined}) // {}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the object to compact",
									"name": "data"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.compact(value)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function compact<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!compact:function(1)",
					"canonicalReferenceGroup": "ts-prime!compact"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function compact<T>(): "
						},
						{
							"kind": "Content",
							"text": "(data: T) => T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!compact:function(2)",
					"canonicalReferenceGroup": "ts-prime!compact"
				}
			],
			"kind": "Function",
			"name": "compact",
			"canonicalReference": "ts-prime!compact:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!compact",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type ComplexSort = "
						},
						{
							"kind": "Content",
							"text": "{\n    order?: 'asc' | 'desc';\n    value: "
						},
						{
							"kind": "Reference",
							"text": "SortValue",
							"canonicalReference": "ts-prime!SortValue:type"
						},
						{
							"kind": "Content",
							"text": ";\n    compare?: (a: "
						},
						{
							"kind": "Reference",
							"text": "SortValue",
							"canonicalReference": "ts-prime!SortValue:type"
						},
						{
							"kind": "Content",
							"text": ", b: "
						},
						{
							"kind": "Reference",
							"text": "SortValue",
							"canonicalReference": "ts-prime!SortValue:type"
						},
						{
							"kind": "Content",
							"text": ") => number;\n}"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!ComplexSort:type",
					"canonicalReferenceGroup": "ts-prime!ComplexSort"
				}
			],
			"kind": "TypeAlias",
			"name": "ComplexSort",
			"canonicalReference": "ts-prime!ComplexSort:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!ComplexSort",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Convert any string to nameCased variant",
						"example": "P.convertStringToNameCase(\"Super#@! ===-0- ball %%% cup\", 'PascalCase') // -> Super0BallCup\nP.convertStringToNameCase(\"Super#@! ===-0- ball %%% cup\", 'camelCase') // -> super0BallCup\nP.convertStringToNameCase(\"Super#@! ===-0- ball %%% cup\", 'snake_case') // -> super_0_ball_cup\nP.convertStringToNameCase(\"Super#@! ===-0- ball %%% cup\", 'kebab-case') // -> super-0-ball-cup\nP.convertStringToNameCase(\"Super#@! ===-0- ball %%% cup\", 'Train-Case') // -> Super-0-Ball-Cup",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the string",
									"name": "str"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "convert string to 'PascalCase' | 'camelCase' | 'snake_case' | 'kebab-case' | 'Train-Case'",
									"name": "to"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.convertStringToNameCase(str",
									"to);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"String"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function convertStringToNameCase(str: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ", to: "
						},
						{
							"kind": "Content",
							"text": "'PascalCase' | 'camelCase' | 'snake_case' | 'kebab-case' | 'Train-Case'"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!convertStringToNameCase:function(1)",
					"canonicalReferenceGroup": "ts-prime!convertStringToNameCase"
				}
			],
			"kind": "Function",
			"name": "convertStringToNameCase",
			"canonicalReference": "ts-prime!convertStringToNameCase:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!convertStringToNameCase",
			"tags": [
				{
					"tag": "@category",
					"value": "String"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Creates a data-last pipe function. First function must be always annotated. Other functions are automatically inferred.",
						"example": "P.createPipe(\n(x: number) => x * 2,\nx => x * 3\n)(1) // => 6",
						"parsed": [
							{
								"tag": "@signature",
								"content": [
									"P.createPipe(op1",
									"op2",
									"op3)(data);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function createPipe<A, B>(op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: A) => B"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!createPipe:function(1)",
					"canonicalReferenceGroup": "ts-prime!createPipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function createPipe<A, B, C>(op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: A) => C"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!createPipe:function(2)",
					"canonicalReferenceGroup": "ts-prime!createPipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function createPipe<A, B, C, D>(op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: A) => D"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!createPipe:function(3)",
					"canonicalReferenceGroup": "ts-prime!createPipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function createPipe<A, B, C, D, E>(op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: A) => E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!createPipe:function(4)",
					"canonicalReferenceGroup": "ts-prime!createPipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function createPipe<A, B, C, D, E, F>(op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": ", op5: "
						},
						{
							"kind": "Content",
							"text": "(input: E) => F"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: A) => F"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!createPipe:function(5)",
					"canonicalReferenceGroup": "ts-prime!createPipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function createPipe<A, B, C, D, E, F, G>(op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": ", op5: "
						},
						{
							"kind": "Content",
							"text": "(input: E) => F"
						},
						{
							"kind": "Content",
							"text": ", op6: "
						},
						{
							"kind": "Content",
							"text": "(input: F) => G"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: A) => G"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!createPipe:function(6)",
					"canonicalReferenceGroup": "ts-prime!createPipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function createPipe<A, B, C, D, E, F, G, H>(op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": ", op5: "
						},
						{
							"kind": "Content",
							"text": "(input: E) => F"
						},
						{
							"kind": "Content",
							"text": ", op6: "
						},
						{
							"kind": "Content",
							"text": "(input: F) => G"
						},
						{
							"kind": "Content",
							"text": ", op7: "
						},
						{
							"kind": "Content",
							"text": "(input: G) => H"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: A) => H"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!createPipe:function(7)",
					"canonicalReferenceGroup": "ts-prime!createPipe"
				}
			],
			"kind": "Function",
			"name": "createPipe",
			"canonicalReference": "ts-prime!createPipe:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!createPipe",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "The Debounce technique allow us to “group” multiple sequential calls in a single one.",
						"example": "const debouncedLog = P.debounce(console.log, 500)\ndebouncedLog(\"I will be printed only if 500ms ago this function was not called\")",
						"parsed": [
							{
								"tag": "@description",
								"content": [
									"https://css-tricks.com/debouncing-throttling-explained-examples/"
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "Any provided function",
									"name": "func"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "duration in milliseconds",
									"name": "debounceTimeMs"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function debounce<E extends "
						},
						{
							"kind": "Content",
							"text": "(...args: any[]) => any"
						},
						{
							"kind": "Content",
							"text": ">(debounceTimeMs: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(func: E) => E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!debounce:function(1)",
					"canonicalReferenceGroup": "ts-prime!debounce"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function debounce<E extends "
						},
						{
							"kind": "Content",
							"text": "(...args: any[]) => any"
						},
						{
							"kind": "Content",
							"text": ">(func: "
						},
						{
							"kind": "Content",
							"text": "E"
						},
						{
							"kind": "Content",
							"text": ", debounceTimeMs: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!debounce:function(2)",
					"canonicalReferenceGroup": "ts-prime!debounce"
				}
			],
			"kind": "Function",
			"name": "debounce",
			"canonicalReference": "ts-prime!debounce:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!debounce",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Decode UTF8 encoded characters",
						"parsed": [
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function decodeUTF8(utftext: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!decodeUTF8:function(1)",
					"canonicalReferenceGroup": "ts-prime!decodeUTF8"
				}
			],
			"kind": "Function",
			"name": "decodeUTF8",
			"canonicalReference": "ts-prime!decodeUTF8:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!decodeUTF8",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Compares two values recursively.",
						"example": "P.deepEquals({\ndata: 1,\nsuper: [{ id: 1, name: \"Tom\" }, { id: 2, name: \"Martin\" }]\n}, {\ndata: 1,\nsuper: [{ id: 2, name: \"Martin\" }, { id: 1, name: \"Tom\" }]\n}) // false super property is not equal\nP.deepEquals({\ndata: 1,\nsuper: [{ id: 1, name: \"Tom\" }, { id: 2, name: \"Martin\" }]\n}, {\ndata: 1,\nsuper: [{ id: 2, name: \"Martin\" }, { id: 1, name: \"Tom\" }]\n}, 'soft') // true Ignores array order",
						"parsed": [
							{
								"tag": "@warning",
								"content": [
									"Soft mode is relative expensive operation."
								]
							},
							{
								"tag": "@description",
								"content": [
									"The function has two modes `soft` and `hard` soft mode ignores array order hard mode preserves array order",
									"- `Soft mode` ignore array order."
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "anything",
									"name": "valueA"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "anything",
									"name": "valueB"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "array comparison mode",
									"name": "mode"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function deepEqual(valueA: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ", valueB: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ", mode?: "
						},
						{
							"kind": "Content",
							"text": "'soft' | 'hard'"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!deepEqual:function(1)",
					"canonicalReferenceGroup": "ts-prime!deepEqual"
				}
			],
			"kind": "Function",
			"name": "deepEqual",
			"canonicalReference": "ts-prime!deepEqual:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!deepEqual",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Merging object from left to right",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "value be preserved if possible.",
									"name": "target"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "value be preserved if possible.",
									"name": "sources"
								}
							},
							{
								"tag": "@description",
								"content": [
									"Consider following",
									"-  `array + obj = array`",
									"-  `obj + array = obj`",
									"-  `obj + obj = obj` (recursively merged)",
									"-  `array + array = array` (removes duplicates using Set)",
									"-  `(truthy plain value) + ob = (truthy plain value)`",
									"-  `(truthy plain value) + undefined = (truthy plain value)`",
									"-  `A(truthy plain value) + B(truthy plain value) = A(truthy plain value)`",
									"Handles circular references"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function deepMergeLeft<T extends "
						},
						{
							"kind": "Content",
							"text": "object"
						},
						{
							"kind": "Content",
							"text": ">(...sources: "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!deepMergeLeft:function(1)",
					"canonicalReferenceGroup": "ts-prime!deepMergeLeft"
				}
			],
			"kind": "Function",
			"name": "deepMergeLeft",
			"canonicalReference": "ts-prime!deepMergeLeft:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!deepMergeLeft",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Merging object from right to left",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "value will be replaced if possible.",
									"name": "target"
								}
							},
							{
								"tag": "@description",
								"content": [
									"Consider following",
									"-  `array + obj = obj`",
									"-  `obj + array = array`",
									"-  `obj + obj = obj` (recursively merged)",
									"-  `array + array = array` (removes duplicates using Set)",
									"-  `(truthy plain value) + undefined = (truthy plain value)`",
									"-  `A(truthy plain value) + B(truthy plain value) = B(truthy plain value)`",
									"Handles circular references"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function deepMergeRight<T extends "
						},
						{
							"kind": "Content",
							"text": "object"
						},
						{
							"kind": "Content",
							"text": ">(...sources: "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!deepMergeRight:function(1)",
					"canonicalReferenceGroup": "ts-prime!deepMergeRight"
				}
			],
			"kind": "Function",
			"name": "deepMergeRight",
			"canonicalReference": "ts-prime!deepMergeRight:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!deepMergeRight",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type DeepPartial<T> = "
						},
						{
							"kind": "Content",
							"text": "T extends "
						},
						{
							"kind": "Reference",
							"text": "Function",
							"canonicalReference": "!Function:interface"
						},
						{
							"kind": "Content",
							"text": " ? T : T extends "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<infer U> ? "
						},
						{
							"kind": "Reference",
							"text": "DeepPartialArray",
							"canonicalReference": "ts-prime!DeepPartialArray:interface"
						},
						{
							"kind": "Content",
							"text": "<U> : T extends object ? "
						},
						{
							"kind": "Reference",
							"text": "DeepPartialObject",
							"canonicalReference": "ts-prime!DeepPartialObject:type"
						},
						{
							"kind": "Content",
							"text": "<T> : T | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!DeepPartial:type",
					"canonicalReferenceGroup": "ts-prime!DeepPartial"
				}
			],
			"kind": "TypeAlias",
			"name": "DeepPartial",
			"canonicalReference": "ts-prime!DeepPartial:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!DeepPartial",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Interface",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export interface DeepPartialArray<T> extends "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "DeepPartial",
							"canonicalReference": "ts-prime!DeepPartial:type"
						},
						{
							"kind": "Content",
							"text": "<T>> "
						}
					],
					"canonicalReference": "ts-prime!DeepPartialArray:interface",
					"canonicalReferenceGroup": "ts-prime!DeepPartialArray"
				}
			],
			"kind": "Interface",
			"name": "DeepPartialArray",
			"canonicalReference": "ts-prime!DeepPartialArray:interface",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!DeepPartialArray",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type DeepPartialObject<T> = "
						},
						{
							"kind": "Content",
							"text": "{\n    [P in keyof T]?: "
						},
						{
							"kind": "Reference",
							"text": "DeepPartial",
							"canonicalReference": "ts-prime!DeepPartial:type"
						},
						{
							"kind": "Content",
							"text": "<T[P]>;\n}"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!DeepPartialObject:type",
					"canonicalReferenceGroup": "ts-prime!DeepPartialObject"
				}
			],
			"kind": "TypeAlias",
			"name": "DeepPartialObject",
			"canonicalReference": "ts-prime!DeepPartialObject:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!DeepPartialObject",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Creates delay",
						"example": "await P.delay(1000)",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Time in milliseconds",
									"name": "ms"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.delay(ms)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function delay(ms: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<void>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!delay:function(1)",
					"canonicalReferenceGroup": "ts-prime!delay"
				}
			],
			"kind": "Function",
			"name": "delay",
			"canonicalReference": "ts-prime!delay:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!delay",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Excludes the values from `other` array.",
						"example": "P.difference([1, 2, 3, 4], [2, 5, 3]) // => [1, 4]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the source array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the values to exclude",
									"name": "other"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.difference(array",
									"other)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							},
							{
								"tag": "@pipeable",
								"content": []
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function difference<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", other: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!difference:function(1)",
					"canonicalReferenceGroup": "ts-prime!difference"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Excludes the values from `other` array.",
						"example": "P.difference([2, 5, 3])([1, 2, 3, 4]) // => [1, 4]\nP.pipe(\n[1, 2, 3, 4, 5, 6], // only 4 iterations\nP.difference([2, 3]),\nP.take(2)\n) // => [1, 4]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the values to exclude",
									"name": "other"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.difference(other)(array)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							},
							{
								"tag": "@pipeable",
								"content": []
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function difference<T, K>(other: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly K[]) => readonly T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!difference:function(2)",
					"canonicalReferenceGroup": "ts-prime!difference"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace difference "
						}
					],
					"canonicalReference": "ts-prime!difference:namespace",
					"canonicalReferenceGroup": "ts-prime!difference"
				}
			],
			"kind": "Function",
			"name": "difference",
			"canonicalReference": "ts-prime!difference:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!difference",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Removes first `n` elements from the `array`.",
						"example": "P.drop([1, 2, 3, 4, 5], 2) // => [1, 2, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the target array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the number of elements to skip",
									"name": "n"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.drop(array",
									"n)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@pipeable",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function drop<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", n: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!drop:function(1)",
					"canonicalReferenceGroup": "ts-prime!drop"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Removes first `n` elements from the `array`.",
						"example": "P.drop(2)([1, 2, 3, 4, 5]) // => [1, 2, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the target array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the number of elements to skip",
									"name": "n"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.drop(n)(array)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@pipeable",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function drop<T>(n: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!drop:function(2)",
					"canonicalReferenceGroup": "ts-prime!drop"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace drop "
						}
					],
					"canonicalReference": "ts-prime!drop:namespace",
					"canonicalReferenceGroup": "ts-prime!drop"
				}
			],
			"kind": "Function",
			"name": "drop",
			"canonicalReference": "ts-prime!drop:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!drop",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Removes last `n` elements from the `array`.",
						"example": "P.dropLast([1, 2, 3, 4, 5], 2) // => [1, 2, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the target array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the number of elements to skip",
									"name": "n"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.dropLast(array",
									"n)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function dropLast<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", n: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!dropLast:function(1)",
					"canonicalReferenceGroup": "ts-prime!dropLast"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Removes last `n` elements from the `array`.",
						"example": "P.dropLast(2)([1, 2, 3, 4, 5]) // => [1, 2, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the target array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the number of elements to skip",
									"name": "n"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.dropLast(n)(array)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function dropLast<T>(n: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!dropLast:function(2)",
					"canonicalReferenceGroup": "ts-prime!dropLast"
				}
			],
			"kind": "Function",
			"name": "dropLast",
			"canonicalReference": "ts-prime!dropLast:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!dropLast",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Encode UTF8 characters",
						"parsed": [
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function encodeUTF8(input: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!encodeUTF8:function(1)",
					"canonicalReferenceGroup": "ts-prime!encodeUTF8"
				}
			],
			"kind": "Function",
			"name": "encodeUTF8",
			"canonicalReference": "ts-prime!encodeUTF8:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!encodeUTF8",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Ensures array data type",
						"example": "ensureArray(1) // => [1]\nensureArray([1]) // => [1]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Item or array",
									"name": "data"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.ensureArray(data)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function ensureArray<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T | readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!ensureArray:function(1)",
					"canonicalReferenceGroup": "ts-prime!ensureArray"
				}
			],
			"kind": "Function",
			"name": "ensureArray",
			"canonicalReference": "ts-prime!ensureArray:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!ensureArray",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Ensures that err is Error instance",
						"example": "const request = doRequest().catch(P.ensureError)\nif (P.isError(request)) return",
						"parsed": [
							{
								"tag": "@signature",
								"content": [
									"P.ensureError(any)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function ensureError(err: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Error",
							"canonicalReference": "!Error:interface"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!ensureError:function(1)",
					"canonicalReferenceGroup": "ts-prime!ensureError"
				}
			],
			"kind": "Function",
			"name": "ensureError",
			"canonicalReference": "ts-prime!ensureError:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!ensureError",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Ensures typescript type",
						"example": "const data = myFunction()\nP.ensureType<number>(data) // If data is not number typescript compiler will complain",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "data object",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function ensureType<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!ensureType:function(1)",
					"canonicalReferenceGroup": "ts-prime!ensureType"
				}
			],
			"kind": "Function",
			"name": "ensureType",
			"canonicalReference": "ts-prime!ensureType:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!ensureType",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns true if its arguments are equivalent, false otherwise.",
						"example": "P.equals(1, 1) //=> true\nP.equals(1, '1') //=> false\nP.equals([1, 2, 3], [1, 2, 3]) //=> true",
						"parsed": [
							{
								"tag": "@warning",
								"content": [
									"Doesn't handle cyclical data structures."
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "the first object to compare",
									"name": "a"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the second object to compare",
									"name": "b"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.equals(a",
									"b)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function equals(a: "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": ", b: "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!equals:function(1)",
					"canonicalReferenceGroup": "ts-prime!equals"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Returns true if its arguments are equivalent, false otherwise.",
						"example": "P.equals(1)(1) //=> true\nP.equals('1')(1) //=> false\nP.equals([1, 2, 3])([1, 2, 3]) //=> true",
						"parsed": [
							{
								"tag": "@warning",
								"content": [
									"Doesn't handle cyclical data structures."
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "the first object to compare",
									"name": "a"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the second object to compare",
									"name": "b"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.equals(b)(a)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function equals(a: "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(b: any) => boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!equals:function(2)",
					"canonicalReferenceGroup": "ts-prime!equals"
				}
			],
			"kind": "Function",
			"name": "equals",
			"canonicalReference": "ts-prime!equals:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!equals",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Filter the elements of an array that meet the condition specified in a callback function.",
						"example": "P.filter([1, 2, 3], x => x % 2 === 1) // => [1, 3]\nP.pipe([1, 2, 3], P.filter(x => x % 2 === 1)) // => [1, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The array to filter.",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the callback function.",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.filter(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.filter(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function filter<T, S extends "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ">(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(value: T) => "
						},
						{
							"kind": "Reference",
							"text": "value",
							"canonicalReference": "ts-prime!~value"
						},
						{
							"kind": "Content",
							"text": " is S"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "S[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!filter:function(1)",
					"canonicalReferenceGroup": "ts-prime!filter"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function filter<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!filter:function(2)",
					"canonicalReferenceGroup": "ts-prime!filter"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function filter<T, S extends "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "(input: T) => "
						},
						{
							"kind": "Reference",
							"text": "input",
							"canonicalReference": "ts-prime!~input"
						},
						{
							"kind": "Content",
							"text": " is S"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => S[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!filter:function(3)",
					"canonicalReferenceGroup": "ts-prime!filter"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function filter<T>(fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!filter:function(4)",
					"canonicalReferenceGroup": "ts-prime!filter"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace filter "
						}
					],
					"canonicalReference": "ts-prime!filter:namespace",
					"canonicalReferenceGroup": "ts-prime!filter"
				}
			],
			"kind": "Function",
			"name": "filter",
			"canonicalReference": "ts-prime!filter:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!filter",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Loops each record element and match against provided predicate.",
						"example": "P.filterRecord({ a: 1, b: 2, c: 3 }, ([k,v]) => [k, v * 2]) // => { a: 2, b: 4, c: 6 }\nP.pipe({ a: 1, b: 2, c: 3 }, P.filterRecord(([k,v]) => [k, v * 2]))) // => { a: 2, b: 4, c: 6 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The object to filter.",
									"name": "record"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Predicate function.",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new filtered record."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.filterRecord(record",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.pipe({ a: 1",
									"b: 2",
									"c: 3 }",
									"P.filterRecord(fn))"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function filterRecord<T extends "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>"
						},
						{
							"kind": "Content",
							"text": ">(record: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<[keyof T, T[keyof T]], any>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<keyof T, T[keyof T]>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!filterRecord:function(1)",
					"canonicalReferenceGroup": "ts-prime!filterRecord"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function filterRecord<T extends "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "(v: [keyof T, T[keyof T]]) => any"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(record: T) => "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<keyof T, T[keyof T]>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!filterRecord:function(2)",
					"canonicalReferenceGroup": "ts-prime!filterRecord"
				}
			],
			"kind": "Function",
			"name": "filterRecord",
			"canonicalReference": "ts-prime!filterRecord:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!filterRecord",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns the value of the first element in the array where predicate is true, and undefined otherwise.",
						"example": "P.find([1, 3, 4, 6], n => n % 2 === 0) // => 4\nP.pipe(\n[1, 3, 4, 6],\nP.find(n => n % 2 === 0)\n) // => 4\nP.pipe(\n[1, 3, 4, 6],\nP.find.indexed((n, i) => n % 2 === 0)\n) // => 4",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "items"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the predicate",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.find(items",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.find(fn)(items)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function find<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!find:function(1)",
					"canonicalReferenceGroup": "ts-prime!find"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function find<T = "
						},
						{
							"kind": "Content",
							"text": "never"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!find:function(2)",
					"canonicalReferenceGroup": "ts-prime!find"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace find "
						}
					],
					"canonicalReference": "ts-prime!find:namespace",
					"canonicalReferenceGroup": "ts-prime!find"
				}
			],
			"kind": "Function",
			"name": "find",
			"canonicalReference": "ts-prime!find:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!find",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns the index of the first element in the array where predicate is true, and -1 otherwise.",
						"example": "P.findIndex([1, 3, 4, 6], n => n % 2 === 0) // => 2\nP.pipe(\n[1, 3, 4, 6],\nP.findIndex(n => n % 2 === 0)\n) // => 4",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "items"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the predicate",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.findIndex(items",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.findIndex(fn)(items)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function findIndex<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!findIndex:function(1)",
					"canonicalReferenceGroup": "ts-prime!findIndex"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function findIndex<T>(fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => number"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!findIndex:function(2)",
					"canonicalReferenceGroup": "ts-prime!findIndex"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace findIndex "
						}
					],
					"canonicalReference": "ts-prime!findIndex:namespace",
					"canonicalReferenceGroup": "ts-prime!findIndex"
				}
			],
			"kind": "Function",
			"name": "findIndex",
			"canonicalReference": "ts-prime!findIndex:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!findIndex",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Gets the first element of `array`.\r\n  Note: In `pipe`, use `first()` form instead of `first`. Otherwise, the inferred type is lost.",
						"example": "P.first([1, 2, 3]) // => 1\nP.first([]) // => undefined\nP.pipe(\n[1, 2, 4, 8, 16],\nP.filter(x => x > 3),\nP.first(),\nx => x + 1\n); // => 5",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "array"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.first(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function first<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!first:function(1)",
					"canonicalReferenceGroup": "ts-prime!first"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function first<T>(): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!first:function(2)",
					"canonicalReferenceGroup": "ts-prime!first"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function first<T>(defaultValue: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!first:function(3)",
					"canonicalReferenceGroup": "ts-prime!first"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace first "
						}
					],
					"canonicalReference": "ts-prime!first:namespace",
					"canonicalReferenceGroup": "ts-prime!first"
				}
			],
			"kind": "Function",
			"name": "first",
			"canonicalReference": "ts-prime!first:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!first",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Map each element of an array using a defined callback function and flatten the mapped result.",
						"example": "P.flatMap([1, 2, 3], x => [x, x * 10]) // => [1, 10, 2, 20, 3, 30]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The array to map.",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The function mapper.",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatMap(array",
									"fn)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@pipeable",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatMap<T, K>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(input: T) => K | readonly K[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "K[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatMap:function(1)",
					"canonicalReferenceGroup": "ts-prime!flatMap"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Map each element of an array using a defined callback function and flatten the mapped result.",
						"example": "P.pipe([1, 2, 3], P.flatMap(x => [x, x * 10])) // => [1, 10, 2, 20, 3, 30]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The array to map.",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The function mapper.",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatMap(fn)(array)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@pipeable",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatMap<T, K>(fn: "
						},
						{
							"kind": "Content",
							"text": "(input: T) => K | K[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => readonly K[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatMap:function(2)",
					"canonicalReferenceGroup": "ts-prime!flatMap"
				}
			],
			"kind": "Function",
			"name": "flatMap",
			"canonicalReference": "ts-prime!flatMap:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!flatMap",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Loops each record element and flatMaps against provided function.",
						"example": "P.flatMapRecord({ a: 1, b: 2, c: 3 }, ([k,v]) => [[k, v * 2], [k + \"_abc\", v * 2]]) // => { a: 2, a_abc: 2, b: 4, b_abc: 4, c: 6, c_abc: 6 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The target object.",
									"name": "record"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Mapping function.",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new record."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatMapRecord(record",
									"fn)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@pipeable",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatMapRecord<T extends "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>"
						},
						{
							"kind": "Content",
							"text": ", K extends "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ", V>(record: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<[keyof T, T[keyof T]], "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<[K, V]>>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatMapRecord:function(1)",
					"canonicalReferenceGroup": "ts-prime!flatMapRecord"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Loops each record element and flatMaps against provided function.",
						"example": "P.pipe(({ a: 1, b: 2, c: 3 }, P.flatMapRecord(([k,v]) => [[k, v * 2], [k + \"_abc\", v * 2]])) // => { a: 2, a_abc: 2, b: 4, b_abc: 4, c: 6, c_abc: 6 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The target object.",
									"name": "record"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Mapping function.",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new record."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.pipe(record",
									"P.flatMapRecord(fn))"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@pipeable",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatMapRecord<T extends "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>"
						},
						{
							"kind": "Content",
							"text": ", K extends "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ", V extends "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "(v: [keyof T, T[keyof T]]) => "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<[K, V]>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(record: T) => "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatMapRecord:function(2)",
					"canonicalReferenceGroup": "ts-prime!flatMapRecord"
				}
			],
			"kind": "Function",
			"name": "flatMapRecord",
			"canonicalReference": "ts-prime!flatMapRecord:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!flatMapRecord",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Map each element of an array into an object using a defined callback function and flatten the result.",
						"example": "P.flatMapToObj([1, 2, 3], (x) =>\nx % 2 === 1 ? [[String(x), x]] : []\n) // => {1: 1, 3: 3}\nP.flatMapToObj.indexed(['a', 'b'], (x, i) => [\n[x, i],\n[x + x, i + i],\n]) // => {a: 0, aa: 0, b: 1, bb: 2}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The array to map.",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The mapping function, which should return an Array of key-value pairs, similar to Object.fromEntries",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new mapped object."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatMapToObj(array",
									"fn)",
									"P.flatMapToObj.indexed(array",
									"fn)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@indexed",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatMapToObj<T, K extends "
						},
						{
							"kind": "Content",
							"text": "string | number | symbol"
						},
						{
							"kind": "Content",
							"text": ", V>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(element: T, index: number, array: readonly T[]) => [K, V][]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatMapToObj:function(1)",
					"canonicalReferenceGroup": "ts-prime!flatMapToObj"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Map each element of an array into an object using a defined callback function and flatten the result.",
						"example": "P.pipe(\n[1, 2, 3],\nP.flatMapToObj(x => (x % 2 === 1 ? [[String(x), x]] : []))\n) // => {1: 1, 3: 3}\nP.pipe(\n['a', 'b'],\nP.flatMapToObj.indexed((x, i) => [\n[x, i],\n[x + x, i + i],\n])\n) // => {a: 0, aa: 0, b: 1, bb: 2}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The mapping function, which should return an Array of key-value pairs, similar to Object.fromEntries",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new mapped object."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatMapToObj(fn)(array)",
									"P.flatMapToObj(fn)(array)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@indexed",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatMapToObj<T, K extends "
						},
						{
							"kind": "Content",
							"text": "string | number | symbol"
						},
						{
							"kind": "Content",
							"text": ", V>(fn: "
						},
						{
							"kind": "Content",
							"text": "(element: T, index: number, array: readonly T[]) => [K, V][]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatMapToObj:function(2)",
					"canonicalReferenceGroup": "ts-prime!flatMapToObj"
				}
			],
			"kind": "Function",
			"name": "flatMapToObj",
			"canonicalReference": "ts-prime!flatMapToObj:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!flatMapToObj",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"example": "P.flatten([[1, 2], [3], [4, 5]]) // => [1, 2, 3, 4, 5]\nP.pipe(\n[[1, 2], [3], [4, 5]],\nP.flatten(),\n); // => [1, 2, 3, 4, 5]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the target array",
									"name": "items"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatten(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							},
							{
								"tag": "@pipeable",
								"content": []
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatten<T>(items: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "Flatten",
							"canonicalReference": "ts-prime!~Flatten:type"
						},
						{
							"kind": "Content",
							"text": "<T>>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatten:function(1)",
					"canonicalReferenceGroup": "ts-prime!flatten"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flatten<T>(): "
						},
						{
							"kind": "Content",
							"text": "(items: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "Flatten",
							"canonicalReference": "ts-prime!~Flatten:type"
						},
						{
							"kind": "Content",
							"text": "<T>>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flatten:function(2)",
					"canonicalReferenceGroup": "ts-prime!flatten"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace flatten "
						}
					],
					"canonicalReference": "ts-prime!flatten:namespace",
					"canonicalReferenceGroup": "ts-prime!flatten"
				}
			],
			"kind": "Function",
			"name": "flatten",
			"canonicalReference": "ts-prime!flatten:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!flatten",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Recursively flattens `array`.\r\n  Note: In `pipe`, use `flattenDeep()` form instead of `flattenDeep`. Otherwise, the inferred type is lost.",
						"example": "P.flattenDeep([[1, 2], [[3], [4, 5]]]) // => [1, 2, 3, 4, 5]\nP.pipe(\n[[1, 2], [[3], [4, 5]]],\nP.flattenDeep(),\n); // => [1, 2, 3, 4, 5]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the target array",
									"name": "items"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.flattenDeep(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							},
							{
								"tag": "@pipeable",
								"content": []
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flattenDeep<T>(items: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "FlattenDeep",
							"canonicalReference": "ts-prime!~FlattenDeep:type"
						},
						{
							"kind": "Content",
							"text": "<T>>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flattenDeep:function(1)",
					"canonicalReferenceGroup": "ts-prime!flattenDeep"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function flattenDeep<T>(): "
						},
						{
							"kind": "Content",
							"text": "(items: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "FlattenDeep",
							"canonicalReference": "ts-prime!~FlattenDeep:type"
						},
						{
							"kind": "Content",
							"text": "<T>>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!flattenDeep:function(2)",
					"canonicalReferenceGroup": "ts-prime!flattenDeep"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace flattenDeep "
						}
					],
					"canonicalReference": "ts-prime!flattenDeep:namespace",
					"canonicalReferenceGroup": "ts-prime!flattenDeep"
				}
			],
			"kind": "Function",
			"name": "flattenDeep",
			"canonicalReference": "ts-prime!flattenDeep:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!flattenDeep",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Construct object from tuple array",
						"example": "P.fromPairs([[\"a\", 5], [\"b\", 4]]) // => { a: 5, b: 4 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "List of tuples",
									"name": "data"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.fromPairs(tuples)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function fromPairs<T extends "
						},
						{
							"kind": "Content",
							"text": "[string, unknown]"
						},
						{
							"kind": "Content",
							"text": ">(data: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, T[1]>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!fromPairs:function(1)",
					"canonicalReferenceGroup": "ts-prime!fromPairs"
				}
			],
			"kind": "Function",
			"name": "fromPairs",
			"canonicalReference": "ts-prime!fromPairs:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!fromPairs",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Splits a collection into sets, grouped by the result of running each value through `fn`.",
						"example": "P.groupBy(['one', 'two', 'three'], x => x.length) // => {3: ['one', 'two'], 5: ['three']}\nP.pipe(['one', 'two', 'three'], P.groupBy(x => x.length)) // => {3: ['one', 'two'], 5: ['three']}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the items to group",
									"name": "items"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the grouping function",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.groupBy(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.groupBy(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function groupBy<T, K extends "
						},
						{
							"kind": "Content",
							"text": "keyof any"
						},
						{
							"kind": "Content",
							"text": ">(items: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => K | "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<K>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, T[]>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!groupBy:function(1)",
					"canonicalReferenceGroup": "ts-prime!groupBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function groupBy<T, K extends "
						},
						{
							"kind": "Content",
							"text": "keyof any"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => K | "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<K>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, T[]>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!groupBy:function(2)",
					"canonicalReferenceGroup": "ts-prime!groupBy"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace groupBy "
						}
					],
					"canonicalReference": "ts-prime!groupBy:namespace",
					"canonicalReferenceGroup": "ts-prime!groupBy"
				}
			],
			"kind": "Function",
			"name": "groupBy",
			"canonicalReference": "ts-prime!groupBy:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!groupBy",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Non cryptographic quality hashing function",
						"example": "P.hash(\"THIS IS AWESOME\") //=> LTU1MjU4ODc4NQ",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Hash content",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function hash(data: "
						},
						{
							"kind": "Content",
							"text": "string | undefined"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!hash:function(1)",
					"canonicalReferenceGroup": "ts-prime!hash"
				}
			],
			"kind": "Function",
			"name": "hash",
			"canonicalReference": "ts-prime!hash:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!hash",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Inverse predicate",
						"example": "const data = [new Error('sample'), 1, 2].filter(P.isNot(P.isError)) // [1,2]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "predicate function",
									"name": "predicate"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function haveKeys<K extends "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ">(keys: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<K>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "<T extends {\n    [k: string]: unknown;\n}>(data: T) => "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is T & {\n    [k in K]: "
						},
						{
							"kind": "Reference",
							"text": "NonNullable",
							"canonicalReference": "!NonNullable:type"
						},
						{
							"kind": "Content",
							"text": "<T[k]>;\n}"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!haveKeys:function(1)",
					"canonicalReferenceGroup": "ts-prime!haveKeys"
				}
			],
			"kind": "Function",
			"name": "haveKeys",
			"canonicalReference": "ts-prime!haveKeys:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!haveKeys",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Return same value",
						"parsed": [
							{
								"tag": "@description",
								"content": [
									"Function that returns provided value"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function identity<T>(value: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!identity:function(1)",
					"canonicalReferenceGroup": "ts-prime!identity"
				}
			],
			"kind": "Function",
			"name": "identity",
			"canonicalReference": "ts-prime!identity:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!identity",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if",
						"example": "P.includesAny(['apple','microsoft','tesla','samsung'],['apple', 'xiomi']) //=> true; Source list contains \"apple\"\nP.includesAny(['apple', 'microsoft'])(['samsung', 'tesla']) //=> false // Source list does not include any of options",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "contains any element of",
									"name": "data"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "and returns boolean",
									"name": "includes"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Value to check",
									"name": "data"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Provided list",
									"name": "includes"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.includesAny(sourceList",
									"includeList)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.includesAny(includeList)(sourceList)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function includesAny<T>(data: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ", includes: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!includesAny:function(1)",
					"canonicalReferenceGroup": "ts-prime!includesAny"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function includesAny<T>(includes: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(data: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>) => boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!includesAny:function(2)",
					"canonicalReferenceGroup": "ts-prime!includesAny"
				}
			],
			"kind": "Function",
			"name": "includesAny",
			"canonicalReference": "ts-prime!includesAny:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!includesAny",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if",
						"example": "P.includesEvery(['apple','microsoft','tesla','samsung'],['apple', 'microsoft']) //=> true; Source list contains \"apple\" and 'microsoft'\nP.includesEvery(['apple', 'microsoft'])(['samsung', 'tesla', 'apple']) //=> false // Source list does not include every of options",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "contains every element of",
									"name": "data"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "and returns boolean",
									"name": "includes"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Value to check",
									"name": "data"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Provided list",
									"name": "includes"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.includesEvery(sourceList",
									"includeList)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.includesEvery(includeList)(sourceList)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function includesEvery<T>(data: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ", includes: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!includesEvery:function(1)",
					"canonicalReferenceGroup": "ts-prime!includesEvery"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function includesEvery<T>(includes: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(data: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>) => boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!includesEvery:function(2)",
					"canonicalReferenceGroup": "ts-prime!includesEvery"
				}
			],
			"kind": "Function",
			"name": "includesEvery",
			"canonicalReference": "ts-prime!includesEvery:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!includesEvery",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Converts a list of objects into an object indexing the objects by the given key.",
						"example": "P.indexBy(['one', 'two', 'three'], x => x.length) // => {3: 'two', 5: 'three'}\nP.pipe(\n['one', 'two', 'three'],\nP.indexBy(x => x.length)\n) // => {3: 'two', 5: 'three'}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the indexing function",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.indexBy(array",
									"fn)",
									"P.indexBy(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function indexBy<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => any"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!indexBy:function(1)",
					"canonicalReferenceGroup": "ts-prime!indexBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function indexBy<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => string | number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!indexBy:function(2)",
					"canonicalReferenceGroup": "ts-prime!indexBy"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace indexBy "
						}
					],
					"canonicalReference": "ts-prime!indexBy:namespace",
					"canonicalReferenceGroup": "ts-prime!indexBy"
				}
			],
			"kind": "Function",
			"name": "indexBy",
			"canonicalReference": "ts-prime!indexBy:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!indexBy",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns a list of elements that exist in both array.",
						"example": "P.intersection([1, 2, 3], [2, 3, 5]) // => [2, 3]\nP.intersection([2, 3, 5])([1, 2, 3]) // => [2, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the source array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the second array",
									"name": "other"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.intersection(array",
									"other)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.intersection(other)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function intersection<T>(source: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", other: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!intersection:function(1)",
					"canonicalReferenceGroup": "ts-prime!intersection"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function intersection<T, K>(other: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(source: readonly K[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!intersection:function(2)",
					"canonicalReferenceGroup": "ts-prime!intersection"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace intersection "
						}
					],
					"canonicalReference": "ts-prime!intersection:namespace",
					"canonicalReferenceGroup": "ts-prime!intersection"
				}
			],
			"kind": "Function",
			"name": "intersection",
			"canonicalReference": "ts-prime!intersection:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!intersection",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is `array`.",
						"example": "const item = { data: 1 } as { data: number } | string[]\nif (P.isArray(item)) {\nconsole.log(item.map((q)=> q.match(/.../)))\n}\nconst items = [{ data: 1 },[],\"1\",4,P.clamp].filter(P.isArray) //=> [\"1\"]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isArray<T extends "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ">(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyArray",
							"canonicalReference": "ts-prime!~DefinitelyArray:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isArray:function(1)",
					"canonicalReferenceGroup": "ts-prime!isArray"
				}
			],
			"kind": "Function",
			"name": "isArray",
			"canonicalReference": "ts-prime!isArray:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isArray",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is boolean",
						"example": "const item = false as { data: number } | undefined | boolean\nif (P.isBoolean(item)) {\nconsole.log(item.data)\n}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isBoolean<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyBoolean",
							"canonicalReference": "ts-prime!~DefinitelyBoolean:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isBoolean:function(1)",
					"canonicalReferenceGroup": "ts-prime!isBoolean"
				}
			],
			"kind": "Function",
			"name": "isBoolean",
			"canonicalReference": "ts-prime!isBoolean:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isBoolean",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is type of `Date`",
						"example": "const item = new Date() as unknown\nif (P.isDate(item)) {\n// This is definitely an Date\n}\nconst items = [1,2,3,4,new Date()].filter(P.isDate) //=> [new Date()]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isDate<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyDate",
							"canonicalReference": "ts-prime!~DefinitelyDate:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isDate:function(1)",
					"canonicalReferenceGroup": "ts-prime!isDate"
				}
			],
			"kind": "Function",
			"name": "isDate",
			"canonicalReference": "ts-prime!isDate:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isDate",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is defined",
						"example": "const item = { data: 1 } as { data: number } | undefined\nif (P.isDefined(item)) {\nconsole.log(item.data)\n}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isDefined<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "NonNullable",
							"canonicalReference": "!NonNullable:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isDefined:function(1)",
					"canonicalReferenceGroup": "ts-prime!isDefined"
				}
			],
			"kind": "Function",
			"name": "isDefined",
			"canonicalReference": "ts-prime!isDefined:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isDefined",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is instance of Error class",
						"example": "const item = new Error('Error') as unknown\nif (P.isError(item)) {\n// This is definitely an error and Typescript resolves it\nconsole.log(item.message)\n}\nconst items = [1,2,3,4,new Error('Error')].filter(P.isError) //=> [new Error('Error')]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isError<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyError",
							"canonicalReference": "ts-prime!~DefinitelyError:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isError:function(1)",
					"canonicalReferenceGroup": "ts-prime!isError"
				}
			],
			"kind": "Function",
			"name": "isError",
			"canonicalReference": "ts-prime!isError:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isError",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is `function`",
						"example": "const item = P.clamp as unknown\nif (P.isNil(item)) {\n// Item is definitely function\nconsole.log('Nice function', item.name)\n}\nconst items = [1,2,3,4,P.clamp].filter(P.isFunction) //=> [P.clamp]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isFunction<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyFunction",
							"canonicalReference": "ts-prime!~DefinitelyFunction:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isFunction:function(1)",
					"canonicalReferenceGroup": "ts-prime!isFunction"
				}
			],
			"kind": "Function",
			"name": "isFunction",
			"canonicalReference": "ts-prime!isFunction:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isFunction",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is `null` or `undefined`. Executes basic `data == null` evaluation",
						"example": "const item = undefined as unknown\nif (P.isNil(item)) {\n// Item is definitely null | undefined\nconsole.log('Do something')\n}\nconst items = [1,2,3,4,undefined].filter(P.isNil) //=> [undefined]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isNil<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "Extract",
							"canonicalReference": "!Extract:type"
						},
						{
							"kind": "Content",
							"text": "<T, null | undefined>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isNil:function(1)",
					"canonicalReferenceGroup": "ts-prime!isNil"
				}
			],
			"kind": "Function",
			"name": "isNil",
			"canonicalReference": "ts-prime!isNil:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isNil",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Inverse predicate",
						"example": "const data = [new Error('sample'), 1, 2].filter(P.isNot(P.isError)) // [1,2]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "predicate function",
									"name": "predicate"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isNot<T, S>(predicate: "
						},
						{
							"kind": "Content",
							"text": "(data: T) => "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is S"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(data: T) => "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "Exclude",
							"canonicalReference": "!Exclude:type"
						},
						{
							"kind": "Content",
							"text": "<T, S>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isNot:function(1)",
					"canonicalReferenceGroup": "ts-prime!isNot"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isNot<T>(predicate: "
						},
						{
							"kind": "Content",
							"text": "(data: T) => any"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(data: T) => boolean"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isNot:function(2)",
					"canonicalReferenceGroup": "ts-prime!isNot"
				}
			],
			"kind": "Function",
			"name": "isNot",
			"canonicalReference": "ts-prime!isNot:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isNot",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is `Number`",
						"example": "const item = { data: 1 } as { data: number } | number\nif (P.isNumber(item)) {\nconsole.log(\"My phone number is\", item)\n}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isNumber<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyNumber",
							"canonicalReference": "ts-prime!~DefinitelyNumber:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isNumber:function(1)",
					"canonicalReferenceGroup": "ts-prime!isNumber"
				}
			],
			"kind": "Function",
			"name": "isNumber",
			"canonicalReference": "ts-prime!isNumber:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isNumber",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is `object`.",
						"example": "const item = { data: 1 } as { data: number } | string[]\nif (P.isObject(item)) {\nconsole.log(item.data)\n}\nconst items = [{ data: 1 },[],1,4,P.clamp].filter(P.isObject) //=> [{ data: 1 }]",
						"parsed": [
							{
								"tag": "@warning",
								"content": [
									"This function does not treat `Array` as `object`"
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isObject<T extends "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ">(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyObject",
							"canonicalReference": "ts-prime!~DefinitelyObject:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isObject:function(1)",
					"canonicalReferenceGroup": "ts-prime!isObject"
				}
			],
			"kind": "Function",
			"name": "isObject",
			"canonicalReference": "ts-prime!isObject:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isObject",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if value is one of provided list",
						"example": "P.isOneOf('apple',['apple', 'microsoft']) //=> true\nP.isOneOf(['apple', 'microsoft'])('apple') //=> true",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Value to check",
									"name": "value"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Provided list",
									"name": "array"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.isOneOf(value",
									"list)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.isOneOf(list)(value)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Guard",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isOneOf<T extends "
						},
						{
							"kind": "Content",
							"text": "string | number | boolean"
						},
						{
							"kind": "Content",
							"text": ">(value: "
						},
						{
							"kind": "Content",
							"text": "string | number | boolean | undefined"
						},
						{
							"kind": "Content",
							"text": ", array: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "value",
							"canonicalReference": "ts-prime!~value"
						},
						{
							"kind": "Content",
							"text": " is T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isOneOf:function(1)",
					"canonicalReferenceGroup": "ts-prime!isOneOf"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isOneOf<T extends "
						},
						{
							"kind": "Content",
							"text": "string | number | boolean"
						},
						{
							"kind": "Content",
							"text": ">(array: "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(value: string | number | boolean | undefined) => "
						},
						{
							"kind": "Reference",
							"text": "value",
							"canonicalReference": "ts-prime!~value"
						},
						{
							"kind": "Content",
							"text": " is T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isOneOf:function(2)",
					"canonicalReferenceGroup": "ts-prime!isOneOf"
				}
			],
			"kind": "Function",
			"name": "isOneOf",
			"canonicalReference": "ts-prime!isOneOf:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isOneOf",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is `Promise`.",
						"example": "const item = { data: 1 } as { data: number } | Promise<string[]>\nif (P.isPromise(item)) {\nconst result = await item\nconsole.log(Promise resolved,result.map((q)=> q.match(/.../)))\n}\n// Item is not promise",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isPromise<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyPromise",
							"canonicalReference": "ts-prime!~DefinitelyPromise:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isPromise:function(1)",
					"canonicalReferenceGroup": "ts-prime!isPromise"
				}
			],
			"kind": "Function",
			"name": "isPromise",
			"canonicalReference": "ts-prime!isPromise:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isPromise",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Checks if `data` is `Number`",
						"example": "const item = { data: 1 } as { data: number } | string\nif (P.isString(item)) {\nconsole.log(\"My name is\", item)\n}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Guard"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function isString<T>(data: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "data",
							"canonicalReference": "ts-prime!~data"
						},
						{
							"kind": "Content",
							"text": " is "
						},
						{
							"kind": "Reference",
							"text": "DefinitelyString",
							"canonicalReference": "ts-prime!~DefinitelyString:type"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!isString:function(1)",
					"canonicalReferenceGroup": "ts-prime!isString"
				}
			],
			"kind": "Function",
			"name": "isString",
			"canonicalReference": "ts-prime!isString:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!isString",
			"tags": [
				{
					"tag": "@category",
					"value": "Guard"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Gets the last element of `array`.",
						"example": "P.last([1, 2, 3]) // => 3\nP.last([]) // => undefined\nP.last([], 2) // => 2\nP.last([1], 2) // => 1",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "default value",
									"name": "defaultValue"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.last(array)",
									"P.last(array",
									"default)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function last<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!last:function(1)",
					"canonicalReferenceGroup": "ts-prime!last"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function last<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", defaultValue: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!last:function(2)",
					"canonicalReferenceGroup": "ts-prime!last"
				}
			],
			"kind": "Function",
			"name": "last",
			"canonicalReference": "ts-prime!last:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!last",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Map each element of an array using a defined callback function.",
						"example": "P.map([1, 2, 3], x => x * 2) // => [2, 4, 6]\nP.pipe([0, 1, 2], P.map(x => x * 2)) // => [2, 4, 6]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The array to map.",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The function mapper.",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new mapped array."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.map(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.map(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function map<T, K>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, K>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "K[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!map:function(1)",
					"canonicalReferenceGroup": "ts-prime!map"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function map<T, K>(fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, K>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => K[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!map:function(2)",
					"canonicalReferenceGroup": "ts-prime!map"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace map "
						}
					],
					"canonicalReference": "ts-prime!map:namespace",
					"canonicalReferenceGroup": "ts-prime!map"
				}
			],
			"kind": "Function",
			"name": "map",
			"canonicalReference": "ts-prime!map:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!map",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Loops each record element and maps against provided function.",
						"example": "P.flatMapRecord({ a: 1, b: 2, c: 3 }, ([k,v]) => [[k, v * 2], [k + \"_abc\", v * 2]]) // => { a: 2, a_abc: 2, b: 4, b_abc: 4, c: 6, c_abc: 6 }\nP.flatMapRecord({ a: 1, b: 2, c: 3 }, ([k,v]) => [[k, v * 2], [k + \"_abc\", v * 2]]) // => { a: 2, a_abc: 2, b: 4, b_abc: 4, c: 6, c_abc: 6 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The target object.",
									"name": "record"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Mapping function.",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new record."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatMapRecord(record",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.flatMapRecord(record",
									"fn)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function mapRecord<T extends "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>"
						},
						{
							"kind": "Content",
							"text": ", K extends "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ", V>(record: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<[keyof T, T[keyof T]], [K, V]>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!mapRecord:function(1)",
					"canonicalReferenceGroup": "ts-prime!mapRecord"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function mapRecord<T extends "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>"
						},
						{
							"kind": "Content",
							"text": ", K extends "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ", V extends "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "(v: [keyof T, T[keyof T]]) => [K, V]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(record: T) => "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!mapRecord:function(2)",
					"canonicalReferenceGroup": "ts-prime!mapRecord"
				}
			],
			"kind": "Function",
			"name": "mapRecord",
			"canonicalReference": "ts-prime!mapRecord:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!mapRecord",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Map each element of an array into an object using a defined callback function.",
						"example": "P.mapToObj([1, 2, 3], x => [String(x), x * 2]) // => {1: 2, 2: 4, 3: 6}\nP.pipe(\n[1, 2, 3],\nP.mapToObj(x => [String(x), x * 2])\n) // => {1: 2, 2: 4, 3: 6}\nP.pipe(\n[0, 0, 0],\nP.mapToObj.indexed((x, i) => [i, i])\n) // => {0: 0, 1: 1, 2: 2}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The array to map.",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The mapping function, which should return a tuple of [key, value], similar to Object.fromEntries",
									"name": "fn"
								}
							},
							{
								"tag": "@returns",
								"content": [
									"The new mapped object."
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.mapToObj(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.mapToObj(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function mapToObj<T, K extends "
						},
						{
							"kind": "Content",
							"text": "string | number | symbol"
						},
						{
							"kind": "Content",
							"text": ", V>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(element: T, index: number, array: readonly T[]) => [K, V]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!mapToObj:function(1)",
					"canonicalReferenceGroup": "ts-prime!mapToObj"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function mapToObj<T, K extends "
						},
						{
							"kind": "Content",
							"text": "string | number | symbol"
						},
						{
							"kind": "Content",
							"text": ", V>(fn: "
						},
						{
							"kind": "Content",
							"text": "(element: T, index: number, array: readonly T[]) => [K, V]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<K, V>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!mapToObj:function(2)",
					"canonicalReferenceGroup": "ts-prime!mapToObj"
				}
			],
			"kind": "Function",
			"name": "mapToObj",
			"canonicalReference": "ts-prime!mapToObj:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!mapToObj",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns a new array containing items that have maximum numeric values defined by `fn` function.",
						"example": "P.maxBy([1,2,3,4,5,6,7,7]) //=> [7]\nP.maxBy([{ data: 5, score: 2 }, { data: 6, score: 5 }], (q) => q.data * q.score) //=> [{ data: 6, score: 5 }]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "List of items",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Selector function",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.maxBy(arrayOfNumbers)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.maxBy(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.maxBy(fn)(array)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.maxBy()(arrayOfNumbers)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Number"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function maxBy(array: "
						},
						{
							"kind": "Content",
							"text": "readonly number[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!maxBy:function(1)",
					"canonicalReferenceGroup": "ts-prime!maxBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function maxBy<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!maxBy:function(2)",
					"canonicalReferenceGroup": "ts-prime!maxBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function maxBy<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!maxBy:function(3)",
					"canonicalReferenceGroup": "ts-prime!maxBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function maxBy(): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly number[]) => number[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!maxBy:function(4)",
					"canonicalReferenceGroup": "ts-prime!maxBy"
				}
			],
			"kind": "Function",
			"name": "maxBy",
			"canonicalReference": "ts-prime!maxBy:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!maxBy",
			"tags": [
				{
					"tag": "@category",
					"value": "Number"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Merges two objects. The same as `Object.assign`.\r\n  `b` object will override properties of `a`.",
						"example": "P.merge({ x: 1, y: 2 }, { y: 10, z: 2 }) // => { x: 1, y: 10, z: 2 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the first object",
									"name": "a"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the second object",
									"name": "b"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.merge(a",
									"b)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function merge<A, B>(a: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", b: "
						},
						{
							"kind": "Content",
							"text": "B"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "A & B"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!merge:function(1)",
					"canonicalReferenceGroup": "ts-prime!merge"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Merges two objects. The same as `Object.assign`. `b` object will override properties of `a`.",
						"example": "P.merge({ y: 10, z: 2 })({ x: 1, y: 2 }) // => { x: 1, y: 10, z: 2 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the second object",
									"name": "b"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.merge(b)(a)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function merge<A, B>(b: "
						},
						{
							"kind": "Content",
							"text": "B"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(a: A) => A & B"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!merge:function(2)",
					"canonicalReferenceGroup": "ts-prime!merge"
				}
			],
			"kind": "Function",
			"name": "merge",
			"canonicalReference": "ts-prime!merge:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!merge",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns a new array containing items that have maximum numeric values defined by `fn` function.",
						"example": "P.minBy([1,2,3,4,5,6,7,7]) //=> [1]\nP.minBy([{ data: 5, score: 2 }, { data: 6, score: 5 }], (q) => q.data * q.score) //=> [{ data: 5, score: 2 }]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "List of items",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Selector function",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.minBy(arrayOfNumbers)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.minBy(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.minBy(fn)(array)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.minBy()(arrayOfNumbers)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Number",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function minBy(array: "
						},
						{
							"kind": "Content",
							"text": "readonly number[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!minBy:function(1)",
					"canonicalReferenceGroup": "ts-prime!minBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function minBy<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!minBy:function(2)",
					"canonicalReferenceGroup": "ts-prime!minBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function minBy(): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly number[]) => number[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!minBy:function(3)",
					"canonicalReferenceGroup": "ts-prime!minBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function minBy<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!minBy:function(4)",
					"canonicalReferenceGroup": "ts-prime!minBy"
				}
			],
			"kind": "Function",
			"name": "minBy",
			"canonicalReference": "ts-prime!minBy:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!minBy",
			"tags": [
				{
					"tag": "@category",
					"value": "Number"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "A function that returns always `undefined`.",
						"parsed": [
							{
								"tag": "@signature",
								"content": [
									"P.noop()"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function noop(): "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!noop:function(1)",
					"canonicalReferenceGroup": "ts-prime!noop"
				}
			],
			"kind": "Function",
			"name": "noop",
			"canonicalReference": "ts-prime!noop:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!noop",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Converts characters like ĖČĘĄ -> ecea, removes non letter and non number characters",
						"example": "P.normalizeString(\"Super#@! ===-0- ball %%% cup\") // => super0ballcup",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the string",
									"name": "str"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.normalizeString(str);"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"String"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function normalizeString(str: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!normalizeString:function(1)",
					"canonicalReferenceGroup": "ts-prime!normalizeString"
				}
			],
			"kind": "Function",
			"name": "normalizeString",
			"canonicalReference": "ts-prime!normalizeString:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!normalizeString",
			"tags": [
				{
					"tag": "@category",
					"value": "String"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns a partial copy of an object omitting the keys specified.",
						"example": "P.omit({ a: 1, b: 2, c: 3, d: 4 }, ['a', 'd']) // => { b: 2, c: 3 }\nP.pipe({ a: 1, b: 2, c: 3, d: 4 }, P.omit(['a', 'd'])) // => { b: 2, c: 3 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the object",
									"name": "object"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the property names",
									"name": "names"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.omit(obj",
									"names);"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.omit(names)(obj);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function omit<T extends "
						},
						{
							"kind": "Content",
							"text": "{}"
						},
						{
							"kind": "Content",
							"text": ", K extends "
						},
						{
							"kind": "Content",
							"text": "keyof T"
						},
						{
							"kind": "Content",
							"text": ">(object: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ", names: "
						},
						{
							"kind": "Content",
							"text": "readonly K[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Omit",
							"canonicalReference": "!Omit:type"
						},
						{
							"kind": "Content",
							"text": "<T, K>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!omit:function(1)",
					"canonicalReferenceGroup": "ts-prime!omit"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function omit<T extends "
						},
						{
							"kind": "Content",
							"text": "{}"
						},
						{
							"kind": "Content",
							"text": ", K extends "
						},
						{
							"kind": "Content",
							"text": "keyof T"
						},
						{
							"kind": "Content",
							"text": ">(names: "
						},
						{
							"kind": "Content",
							"text": "readonly K[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(object: T) => "
						},
						{
							"kind": "Reference",
							"text": "Omit",
							"canonicalReference": "!Omit:type"
						},
						{
							"kind": "Content",
							"text": "<T, K>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!omit:function(2)",
					"canonicalReferenceGroup": "ts-prime!omit"
				}
			],
			"kind": "Function",
			"name": "omit",
			"canonicalReference": "ts-prime!omit:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!omit",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Creates a function that is restricted to invoking `func` once. Repeat calls to the function return the value of the first invocation.",
						"example": "const initialize = P.once(createApplication);\ninitialize();\ninitialize();\n// => `createApplication` is invoked once",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the function to wrap",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.once(fn)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function once<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "() => T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "() => T"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!once:function(1)",
					"canonicalReferenceGroup": "ts-prime!once"
				}
			],
			"kind": "Function",
			"name": "once",
			"canonicalReference": "ts-prime!once:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!once",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Filter the elements of an array that meet the condition specified in a callback function.",
						"example": "P.filter([1, 2, 3], x => x % 2 === 1) // => [1, 3]\nP.pipe([1, 2, 3], P.filter(x => x % 2 === 1)) // => [1, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The array to filter.",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the callback function.",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.filter(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.filter(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function partition<T, S extends "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ">(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(value: T) => "
						},
						{
							"kind": "Reference",
							"text": "value",
							"canonicalReference": "ts-prime!~value"
						},
						{
							"kind": "Content",
							"text": " is S"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "[S[], "
						},
						{
							"kind": "Reference",
							"text": "Exclude",
							"canonicalReference": "!Exclude:type"
						},
						{
							"kind": "Content",
							"text": "<T, S>[]]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!partition:function(1)",
					"canonicalReferenceGroup": "ts-prime!partition"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function partition<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!partition:function(2)",
					"canonicalReferenceGroup": "ts-prime!partition"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function partition<T, S extends "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "(input: T) => "
						},
						{
							"kind": "Reference",
							"text": "input",
							"canonicalReference": "ts-prime!~input"
						},
						{
							"kind": "Content",
							"text": " is S"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => [S[], "
						},
						{
							"kind": "Reference",
							"text": "Exclude",
							"canonicalReference": "!Exclude:type"
						},
						{
							"kind": "Content",
							"text": "<T, S>[]]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!partition:function(3)",
					"canonicalReferenceGroup": "ts-prime!partition"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function partition<T>(fn: "
						},
						{
							"kind": "Reference",
							"text": "Pred",
							"canonicalReference": "ts-prime!Pred:type"
						},
						{
							"kind": "Content",
							"text": "<T, boolean>"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => [T[], T[]]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!partition:function(4)",
					"canonicalReferenceGroup": "ts-prime!partition"
				}
			],
			"kind": "Function",
			"name": "partition",
			"canonicalReference": "ts-prime!partition:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!partition",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Gets the value at `path` of `object`",
						"example": "P.path({x: { y: 1 }}, ['x', 'y']) // 1\nP.path({x: { y: 1 }}, ['y']) // undefined\nP.pipe({x: { y: { z: { a: [0] }} }}, P.path(\"x.y.z.a.0\".split('.'))) // 0",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the target object",
									"name": "object"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the path of the property to get",
									"name": "path"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.path(object",
									"path)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.path(path)(object)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function path(object: "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>"
						},
						{
							"kind": "Content",
							"text": ", path: "
						},
						{
							"kind": "Content",
							"text": "readonly string[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!path:function(1)",
					"canonicalReferenceGroup": "ts-prime!path"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function path(path: "
						},
						{
							"kind": "Content",
							"text": "readonly (string | number)[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(object: "
						},
						{
							"kind": "Reference",
							"text": "Record",
							"canonicalReference": "!Record:type"
						},
						{
							"kind": "Content",
							"text": "<string, unknown>) => unknown"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!path:function(2)",
					"canonicalReferenceGroup": "ts-prime!path"
				}
			],
			"kind": "Function",
			"name": "path",
			"canonicalReference": "ts-prime!path:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!path",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Perform left-to-right function composition.",
						"example": "P.pipe(\n[1, 2, 3, 4],\nP.map(x => x * 2),\narr => [arr[0] + arr[1], arr[2] + arr[3]],\n) // => [6, 14]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The initial value.",
									"name": "value"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the list of operations to apply.",
									"name": "operations"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.pipe(data",
									"op1",
									"op2",
									"op3)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function pipe<A, B>(value: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "B"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!pipe:function(1)",
					"canonicalReferenceGroup": "ts-prime!pipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function pipe<A, B, C>(value: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "C"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!pipe:function(2)",
					"canonicalReferenceGroup": "ts-prime!pipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function pipe<A, B, C, D>(value: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "D"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!pipe:function(3)",
					"canonicalReferenceGroup": "ts-prime!pipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function pipe<A, B, C, D, E>(value: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!pipe:function(4)",
					"canonicalReferenceGroup": "ts-prime!pipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function pipe<A, B, C, D, E, F>(value: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": ", op5: "
						},
						{
							"kind": "Content",
							"text": "(input: E) => F"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "F"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!pipe:function(5)",
					"canonicalReferenceGroup": "ts-prime!pipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function pipe<A, B, C, D, E, F, G>(value: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": ", op5: "
						},
						{
							"kind": "Content",
							"text": "(input: E) => F"
						},
						{
							"kind": "Content",
							"text": ", op6: "
						},
						{
							"kind": "Content",
							"text": "(input: F) => G"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "G"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!pipe:function(6)",
					"canonicalReferenceGroup": "ts-prime!pipe"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function pipe<A, B, C, D, E, F, G, H>(value: "
						},
						{
							"kind": "Content",
							"text": "A"
						},
						{
							"kind": "Content",
							"text": ", op1: "
						},
						{
							"kind": "Content",
							"text": "(input: A) => B"
						},
						{
							"kind": "Content",
							"text": ", op2: "
						},
						{
							"kind": "Content",
							"text": "(input: B) => C"
						},
						{
							"kind": "Content",
							"text": ", op3: "
						},
						{
							"kind": "Content",
							"text": "(input: C) => D"
						},
						{
							"kind": "Content",
							"text": ", op4: "
						},
						{
							"kind": "Content",
							"text": "(input: D) => E"
						},
						{
							"kind": "Content",
							"text": ", op5: "
						},
						{
							"kind": "Content",
							"text": "(input: E) => F"
						},
						{
							"kind": "Content",
							"text": ", op6: "
						},
						{
							"kind": "Content",
							"text": "(input: F) => G"
						},
						{
							"kind": "Content",
							"text": ", op7: "
						},
						{
							"kind": "Content",
							"text": "(input: G) => H"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "H"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!pipe:function(7)",
					"canonicalReferenceGroup": "ts-prime!pipe"
				}
			],
			"kind": "Function",
			"name": "pipe",
			"canonicalReference": "ts-prime!pipe:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!pipe",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type PredIndexed<T, K> = "
						},
						{
							"kind": "Content",
							"text": "(input: T, index: number, array: readonly T[]) => K"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!PredIndexed:type",
					"canonicalReferenceGroup": "ts-prime!PredIndexed"
				}
			],
			"kind": "TypeAlias",
			"name": "PredIndexed",
			"canonicalReference": "ts-prime!PredIndexed:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!PredIndexed",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Creates a function with `data-first` and `data-last` signatures.\r\n \r\n  `purry` is a dynamic function and it's not type safe. It should be wrapped by a function that have proper typings.\r\n  Refer to the example below for correct usage.",
						"example": "function _findIndex(array, fn) {\nfor (let i = 0; i < array.length; i++) {\nif (fn(array[i])) {\nreturn i;\n}\n}\nreturn -1;\n}\n// data-first\nfunction findIndex<T>(array: T[], fn: (item: T) => boolean): number;\n// data-last\nfunction findIndex<T>(fn: (item: T) => boolean): (array: T[]) => number;\nfunction findIndex() {\nreturn P.purry(_findIndex, arguments);\n}",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the function to purry.",
									"name": "fn"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the arguments",
									"name": "args"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.purry(fn",
									"arguments);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function purry(fn: "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": ", args: "
						},
						{
							"kind": "Reference",
							"text": "IArguments",
							"canonicalReference": "!IArguments:interface"
						},
						{
							"kind": "Content",
							"text": " | readonly any[]"
						},
						{
							"kind": "Content",
							"text": ", lazy?: "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!purry:function(1)",
					"canonicalReferenceGroup": "ts-prime!purry"
				}
			],
			"kind": "Function",
			"name": "purry",
			"canonicalReference": "ts-prime!purry:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!purry",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Random a non-cryptographic random string from characters a-zA-Z0-9.",
						"example": "randomString(5) // => aB92J",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the length of the random string",
									"name": "length"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"randomString(length)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"String"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function randomString(length: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!randomString:function(1)",
					"canonicalReferenceGroup": "ts-prime!randomString"
				}
			],
			"kind": "Function",
			"name": "randomString",
			"canonicalReference": "ts-prime!randomString:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!randomString",
			"tags": [
				{
					"tag": "@category",
					"value": "String"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns a list of numbers from `start` (inclusive) to `end` (exclusive).",
						"example": "P.range(1, 5) // => [1, 2, 3, 4]\nP.range(5)(1) // => [1, 2, 3, 4]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the start number",
									"name": "start"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the end number",
									"name": "end"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.range(start",
									"end)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.range(end)(start)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function range(start: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ", end: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!range:function(1)",
					"canonicalReferenceGroup": "ts-prime!range"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function range(end: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(start: number) => number[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!range:function(2)",
					"canonicalReferenceGroup": "ts-prime!range"
				}
			],
			"kind": "Function",
			"name": "range",
			"canonicalReference": "ts-prime!range:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!range",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
						"example": "P.reduce([1, 2, 3, 4, 5], (acc, x) => acc + x, 100) // => 115\nP.reduce.indexed([1, 2, 3, 4, 5], (acc, x, i, array) => acc + x, 100) // => 115",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array to reduce",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the callback function",
									"name": "fn"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the initial value to use as an accumulator value in the callback function",
									"name": "initialValue"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.reduce(items",
									"fn",
									"initialValue)",
									"P.reduce.indexed(items",
									"fn",
									"initialValue)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@indexed",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function reduce<T, K>(items: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(acc: K, item: T) => K"
						},
						{
							"kind": "Content",
							"text": ", initialValue: "
						},
						{
							"kind": "Content",
							"text": "K"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "K"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!reduce:function(1)",
					"canonicalReferenceGroup": "ts-prime!reduce"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
						"example": "P.pipe([1, 2, 3, 4, 5], P.reduce((acc, x) => acc + x, 100)) // => 115\nP.pipe([1, 2, 3, 4, 5], P.reduce.indexed((acc, x, i, array) => acc + x, 100)) // => 115",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the callback function",
									"name": "fn"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the initial value to use as an accumulator value in the callback function",
									"name": "initialValue"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.reduce(fn",
									"initialValue)(array)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@indexed",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function reduce<T, K>(fn: "
						},
						{
							"kind": "Content",
							"text": "(acc: K, item: T) => K"
						},
						{
							"kind": "Content",
							"text": ", initialValue: "
						},
						{
							"kind": "Content",
							"text": "K"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(items: readonly T[]) => K"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!reduce:function(2)",
					"canonicalReferenceGroup": "ts-prime!reduce"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace reduce "
						}
					],
					"canonicalReference": "ts-prime!reduce:namespace",
					"canonicalReferenceGroup": "ts-prime!reduce"
				}
			],
			"kind": "Function",
			"name": "reduce",
			"canonicalReference": "ts-prime!reduce:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!reduce",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Retry promise function",
						"example": "P.retry(async () => {\nawait delay(1000)\nthrow new Error(\"Failed!\")\n}, ({ count }) => count < 10) // Retry function 10 times",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Logic when to retry",
									"name": "errorHandler"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the callback function",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.retry(fn",
									"errorHandler)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function retry<E extends "
						},
						{
							"kind": "Content",
							"text": "(...args: any[]) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<any>"
						},
						{
							"kind": "Content",
							"text": ">(errorHandler: "
						},
						{
							"kind": "Content",
							"text": "(stats: {\n    err: "
						},
						{
							"kind": "Reference",
							"text": "Error",
							"canonicalReference": "!Error:interface"
						},
						{
							"kind": "Content",
							"text": ";\n    count: number;\n}) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<boolean> | boolean"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(fn: E) => E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!retry:function(1)",
					"canonicalReferenceGroup": "ts-prime!retry"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Retry promise function",
						"example": "P.retry(async () => {\nawait delay(1000)\nthrow new Error(\"Failed!\")\n}, ({ count }) => count < 10) // Retry function 10 times",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Logic when to retry",
									"name": "errorHandler"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the callback function",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.retry(fn",
									"errorHandler)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function retry<E extends "
						},
						{
							"kind": "Content",
							"text": "(...args: any[]) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<any>"
						},
						{
							"kind": "Content",
							"text": ">(fn: "
						},
						{
							"kind": "Content",
							"text": "E"
						},
						{
							"kind": "Content",
							"text": ", errorHandler: "
						},
						{
							"kind": "Content",
							"text": "(stats: {\n    err: "
						},
						{
							"kind": "Reference",
							"text": "Error",
							"canonicalReference": "!Error:interface"
						},
						{
							"kind": "Content",
							"text": ";\n    count: number;\n}) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<boolean> | boolean"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!retry:function(2)",
					"canonicalReferenceGroup": "ts-prime!retry"
				}
			],
			"kind": "Function",
			"name": "retry",
			"canonicalReference": "ts-prime!retry:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!retry",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Reverses array.",
						"example": "P.reverse([1, 2, 3]) // [3, 2, 1]\nP.reverse()([1, 2, 3]) // [3, 2, 1]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "array"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.reverse(arr);"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.reverse()(array);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function reverse<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!reverse:function(1)",
					"canonicalReferenceGroup": "ts-prime!reverse"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function reverse<T>(): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<T>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!reverse:function(2)",
					"canonicalReferenceGroup": "ts-prime!reverse"
				}
			],
			"kind": "Function",
			"name": "reverse",
			"canonicalReference": "ts-prime!reverse:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!reverse",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Dynamically sets object path",
						"example": "```ts\nP.setPath({ data: {} }, \"data.value.max\", 100) // { data: { value: { max: 100 } } }\n```",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Target object",
									"name": "target"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Path in object",
									"name": "path"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "On final object element",
									"name": "value"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.setPath(obj",
									"path",
									"value)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function setPath(target: "
						},
						{
							"kind": "Content",
							"text": "{\n    [k: string]: unknown;\n} | "
						},
						{
							"kind": "Reference",
							"text": "Array",
							"canonicalReference": "!Array:interface"
						},
						{
							"kind": "Content",
							"text": "<unknown>"
						},
						{
							"kind": "Content",
							"text": ", path: "
						},
						{
							"kind": "Content",
							"text": "(string | number)[]"
						},
						{
							"kind": "Content",
							"text": ", value: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!setPath:function(1)",
					"canonicalReferenceGroup": "ts-prime!setPath"
				}
			],
			"kind": "Function",
			"name": "setPath",
			"canonicalReference": "ts-prime!setPath:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!setPath",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Converts any string to slug",
						"example": "P.slugify(\"Super ball cup\") // => super-ball-cup",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the string",
									"name": "str"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.slugify(str);"
								]
							},
							{
								"tag": "@category",
								"content": [
									"String"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function slugify(str: "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!slugify:function(1)",
					"canonicalReferenceGroup": "ts-prime!slugify"
				}
			],
			"kind": "Function",
			"name": "slugify",
			"canonicalReference": "ts-prime!slugify:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!slugify",
			"tags": [
				{
					"tag": "@category",
					"value": "String"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Sorts an array. The comparator function should accept two values at a time and return a negative number if the first value is smaller, a positive number if it's larger, and zero if they are equal.\r\n  Sorting is based on a native `sort` function. It's not guaranteed to be stable.",
						"example": "P.sort([4, 2, 7, 5], (a, b) => a - b) // => [2, 4, 5, 7]\nP.pipe([4, 2, 7, 5], P.sort((a, b) => a - b)) // => [2, 4, 5, 7]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array to sort",
									"name": "items"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the comparator function",
									"name": "cmp"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.sort(items",
									"cmp)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.sort(cmp)(items)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function sort<T>(items: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", cmp: "
						},
						{
							"kind": "Content",
							"text": "(a: T, b: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!sort:function(1)",
					"canonicalReferenceGroup": "ts-prime!sort"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function sort<T>(cmp: "
						},
						{
							"kind": "Content",
							"text": "(a: T, b: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(items: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!sort:function(2)",
					"canonicalReferenceGroup": "ts-prime!sort"
				}
			],
			"kind": "Function",
			"name": "sort",
			"canonicalReference": "ts-prime!sort:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!sort",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Sorts the list according to the supplied function in ascending order.\r\n  Sorting is based on a native `sort` function. It's not guaranteed to be stable.",
						"example": "P.sortBy(\n[{ a: 1 }, { a: 3 }, { a: 7 }, { a: 2 }],\nx => x.a\n)\n// => [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 7 }]\nP.pipe(\n[{ a: 1 }, { a: 3 }, { a: 7 }, { a: 2 }],\nP.sortBy(x => x.a)\n) // => [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 7 }]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array to sort",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the mapping function",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.sortBy(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.sortBy(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function sortBy<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => "
						},
						{
							"kind": "Reference",
							"text": "SortByProp",
							"canonicalReference": "ts-prime!SortByProp:type"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!sortBy:function(1)",
					"canonicalReferenceGroup": "ts-prime!sortBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function sortBy<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => "
						},
						{
							"kind": "Reference",
							"text": "SortByProp",
							"canonicalReference": "ts-prime!SortByProp:type"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!sortBy:function(2)",
					"canonicalReferenceGroup": "ts-prime!sortBy"
				}
			],
			"kind": "Function",
			"name": "sortBy",
			"canonicalReference": "ts-prime!sortBy:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!sortBy",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type SortByProp = "
						},
						{
							"kind": "Reference",
							"text": "SortValue",
							"canonicalReference": "ts-prime!SortValue:type"
						},
						{
							"kind": "Content",
							"text": " | "
						},
						{
							"kind": "Reference",
							"text": "ComplexSort",
							"canonicalReference": "ts-prime!ComplexSort:type"
						},
						{
							"kind": "Content",
							"text": " | ("
						},
						{
							"kind": "Reference",
							"text": "SortValue",
							"canonicalReference": "ts-prime!SortValue:type"
						},
						{
							"kind": "Content",
							"text": " | "
						},
						{
							"kind": "Reference",
							"text": "ComplexSort",
							"canonicalReference": "ts-prime!ComplexSort:type"
						},
						{
							"kind": "Content",
							"text": ")[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!SortByProp:type",
					"canonicalReferenceGroup": "ts-prime!SortByProp"
				}
			],
			"kind": "TypeAlias",
			"name": "SortByProp",
			"canonicalReference": "ts-prime!SortByProp:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!SortByProp",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "TypeAlias",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare type SortValue = "
						},
						{
							"kind": "Content",
							"text": "boolean | number | string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!SortValue:type",
					"canonicalReferenceGroup": "ts-prime!SortValue"
				}
			],
			"kind": "TypeAlias",
			"name": "SortValue",
			"canonicalReference": "ts-prime!SortValue:type",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!SortValue",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Splits a given array at a given index.",
						"example": "P.splitAt([1, 2, 3], 1) // => [[1], [2, 3]]\nP.splitAt([1, 2, 3, 4, 5], -1) // => [[1, 2, 3, 4], [5]]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array to split",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the index to split at",
									"name": "index"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.splitAt(array",
									"index)"
								]
							},
							{
								"tag": "@data_first",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function splitAt<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", index: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "[T[], T[]]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!splitAt:function(1)",
					"canonicalReferenceGroup": "ts-prime!splitAt"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "Splits a given array at a given index.",
						"example": "P.splitAt(1)([1, 2, 3]) // => [[1], [2, 3]]\nP.splitAt(-1)([1, 2, 3, 4, 5]) // => [[1, 2, 3, 4], [5]]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array to split",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the index to split at",
									"name": "index"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.splitAt(index)(array)"
								]
							},
							{
								"tag": "@data_last",
								"content": []
							},
							{
								"tag": "@category",
								"content": [
									"Array"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function splitAt<T>(index: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => [T[], T[]]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!splitAt:function(2)",
					"canonicalReferenceGroup": "ts-prime!splitAt"
				}
			],
			"kind": "Function",
			"name": "splitAt",
			"canonicalReference": "ts-prime!splitAt:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!splitAt",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Splits a given array at the first index where the given predicate returns true.",
						"example": "P.splitWhen([1, 2, 3], x => x === 2) // => [[1], [2, 3]]\nP.splitWhen(x => x === 2)([1, 2, 3]) // => [[1], [2, 3]]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array to split",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the predicate",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.splitWhen(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.splitWhen(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function splitWhen<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => boolean"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "[T[], T[]]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!splitWhen:function(1)",
					"canonicalReferenceGroup": "ts-prime!splitWhen"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function splitWhen<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => boolean"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => [T[], T[]]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!splitWhen:function(2)",
					"canonicalReferenceGroup": "ts-prime!splitWhen"
				}
			],
			"kind": "Function",
			"name": "splitWhen",
			"canonicalReference": "ts-prime!splitWhen:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!splitWhen",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Calculate objet numeric statistics",
						"example": "P.stats([{ data: 1 }, { data: 2 }, { data: 3 }], (q) => q.data) // => { sum: 6, middle: 2, min: 1, max: 3, arithmetic_mean: 2, geometric_mean: 6, median: 2, quadratic_mean: 14 }\nP.pipe([1, 2, 3], P.stats((q) => q)) // => { sum: 6, middle: 2, min: 1, max: 3, arithmetic_mean: 2, geometric_mean: 6, median: 2, quadratic_mean: 14 }",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Array of data",
									"name": "data"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Function that maps to numeric data",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.stats(data",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.pipe(data",
									"P.stats(fn))"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Number",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function stats<T>(data: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Stats",
							"canonicalReference": "ts-prime!Stats:interface"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!stats:function(1)",
					"canonicalReferenceGroup": "ts-prime!stats"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function stats(data: "
						},
						{
							"kind": "Content",
							"text": "readonly number[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Stats",
							"canonicalReference": "ts-prime!Stats:interface"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!stats:function(2)",
					"canonicalReferenceGroup": "ts-prime!stats"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function stats<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => "
						},
						{
							"kind": "Reference",
							"text": "Stats",
							"canonicalReference": "ts-prime!Stats:interface"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!stats:function(3)",
					"canonicalReferenceGroup": "ts-prime!stats"
				}
			],
			"kind": "Function",
			"name": "stats",
			"canonicalReference": "ts-prime!stats:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!stats",
			"tags": [
				{
					"tag": "@category",
					"value": "Number"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Interface",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export interface Stats "
						}
					],
					"canonicalReference": "ts-prime!Stats:interface",
					"canonicalReferenceGroup": "ts-prime!Stats"
				}
			],
			"kind": "Interface",
			"name": "Stats",
			"canonicalReference": "ts-prime!Stats:interface",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!Stats",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns the first `n` elements of `array`.",
						"example": "P.take([1, 2, 3, 4, 3, 2, 1], 3) // => [1, 2, 3]\nP.pipe([1, 2, 3, 4, 3, 2, 1], P.take(n)) // => [1, 2, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the number of elements to take",
									"name": "n"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.take(array",
									"n)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.take(n)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function take<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", n: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!take:function(1)",
					"canonicalReferenceGroup": "ts-prime!take"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function take<T>(n: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!take:function(2)",
					"canonicalReferenceGroup": "ts-prime!take"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace take "
						}
					],
					"canonicalReference": "ts-prime!take:namespace",
					"canonicalReferenceGroup": "ts-prime!take"
				}
			],
			"kind": "Function",
			"name": "take",
			"canonicalReference": "ts-prime!take:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!take",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns elements from the array until predicate returns false.",
						"example": "P.takeWhile([1, 2, 3, 4, 3, 2, 1], x => x !== 4) // => [1, 2, 3]\nP.pipe([1, 2, 3, 4, 3, 2, 1], P.takeWhile(x => x !== 4))  // => [1, 2, 3]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "the array",
									"name": "array"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "the predicate",
									"name": "fn"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.takeWhile(array",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.takeWhile(fn)(array)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function takeWhile<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => boolean"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!takeWhile:function(1)",
					"canonicalReferenceGroup": "ts-prime!takeWhile"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function takeWhile<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => boolean"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!takeWhile:function(2)",
					"canonicalReferenceGroup": "ts-prime!takeWhile"
				}
			],
			"kind": "Function",
			"name": "takeWhile",
			"canonicalReference": "ts-prime!takeWhile:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!takeWhile",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "The Debounce technique allow us to “group” multiple sequential calls in a single one.",
						"example": "// Execute log\nP.throttle(console.log, 1000)",
						"parsed": [
							{
								"tag": "@description",
								"content": [
									"You can find great article that explains how throttle works [here](https://css-tricks.com/debouncing-throttling-explained-examples/)"
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "Any provided function",
									"name": "func"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "duration in milliseconds",
									"name": "debounceTimeMs"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.throttle(func",
									"throttleTimeMs)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Function"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function throttle<E extends "
						},
						{
							"kind": "Content",
							"text": "(...args: any[]) => any"
						},
						{
							"kind": "Content",
							"text": ">(func: "
						},
						{
							"kind": "Content",
							"text": "E"
						},
						{
							"kind": "Content",
							"text": ", throttleTimeMs: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!throttle:function(1)",
					"canonicalReferenceGroup": "ts-prime!throttle"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function throttle<E extends "
						},
						{
							"kind": "Content",
							"text": "(...args: any[]) => any"
						},
						{
							"kind": "Content",
							"text": ">(throttleTimeMs: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(func: E) => E"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!throttle:function(2)",
					"canonicalReferenceGroup": "ts-prime!throttle"
				}
			],
			"kind": "Function",
			"name": "throttle",
			"canonicalReference": "ts-prime!throttle:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!throttle",
			"tags": [
				{
					"tag": "@category",
					"value": "Function"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Prevents promise to execute longer than X ms",
						"example": "const req = P.timeout(request, 500)\nreq({ ... }) // Will throw if function executes longer than 500ms",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The function to invoke.",
									"name": "fn"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Duration in milliseconds",
									"name": "maxDuration"
								}
							},
							{
								"tag": "@throws",
								"content": [
									"If provided function executes longer than `maxDuration` milliseconds"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.timeout(fn",
									"milliseconds)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.timeout(milliseconds)(fn)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function timeout<I extends "
						},
						{
							"kind": "Content",
							"text": "any[]"
						},
						{
							"kind": "Content",
							"text": ", R>(fn: "
						},
						{
							"kind": "Content",
							"text": "(...args: I) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<R>"
						},
						{
							"kind": "Content",
							"text": ", maxDuration: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(...args: I) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<R>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!timeout:function(1)",
					"canonicalReferenceGroup": "ts-prime!timeout"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function timeout<I extends "
						},
						{
							"kind": "Content",
							"text": "any[]"
						},
						{
							"kind": "Content",
							"text": ", R>(maxDuration: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(fn: (...args: I) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<R>) => (...args: I) => "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<R>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!timeout:function(2)",
					"canonicalReferenceGroup": "ts-prime!timeout"
				}
			],
			"kind": "Function",
			"name": "timeout",
			"canonicalReference": "ts-prime!timeout:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!timeout",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Calls an input function `n` times, returning an array containing the results\r\n  of those function calls.",
						"example": "P.times(identity, 5); //=> [0, 1, 2, 3, 4]",
						"parsed": [
							{
								"tag": "@description",
								"content": [
									"`fn` is passed one argument: The current value of `n`",
									"which begins at `0`",
									"and is gradually incremented to `n - 1`."
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "A value between `0` and `n - 1`. Increments after each function call.",
									"name": "count"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "The function to invoke. Passed one argument, the current value of `n`.",
									"name": "fn"
								}
							},
							{
								"tag": "@return",
								"content": [
									"An array containing the return values of all calls to `fn`."
								]
							},
							{
								"tag": "@throws",
								"content": [
									"If count is less than 0"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.times(5",
									"fn)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.times(fn)(count)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function times<T>(count: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ", fn: "
						},
						{
							"kind": "Content",
							"text": "(n: number) => T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!times:function(1)",
					"canonicalReferenceGroup": "ts-prime!times"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function times<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "(n: number) => T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(count: number) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!times:function(2)",
					"canonicalReferenceGroup": "ts-prime!times"
				}
			],
			"kind": "Function",
			"name": "times",
			"canonicalReference": "ts-prime!times:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!times",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Parses date and if success returns Date object otherwise returns undefined",
						"example": "P.toFloat(\"1.378998\") // = 1.378998\nP.toFloat(\"test\") // undefined\nP.toFloat(\"test\", 0) // 0",
						"parsed": [
							{
								"tag": "@description",
								"content": [
									"If for example we want parse data new Date(\"asd\") this will be invalid date and javascript will not return exception. So for every date parsing we need to do additional validity checks"
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Number"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function toDate(data: "
						},
						{
							"kind": "Content",
							"text": "string | number | "
						},
						{
							"kind": "Reference",
							"text": "Date",
							"canonicalReference": "!Date:interface"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Date",
							"canonicalReference": "!Date:interface"
						},
						{
							"kind": "Content",
							"text": " | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!toDate:function(1)",
					"canonicalReferenceGroup": "ts-prime!toDate"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function toDate(data: "
						},
						{
							"kind": "Content",
							"text": "string | number | "
						},
						{
							"kind": "Reference",
							"text": "Date",
							"canonicalReference": "!Date:interface"
						},
						{
							"kind": "Content",
							"text": ", defaultValue: "
						},
						{
							"kind": "Reference",
							"text": "Date",
							"canonicalReference": "!Date:interface"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Date",
							"canonicalReference": "!Date:interface"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!toDate:function(2)",
					"canonicalReferenceGroup": "ts-prime!toDate"
				}
			],
			"kind": "Function",
			"name": "toDate",
			"canonicalReference": "ts-prime!toDate:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!toDate",
			"tags": [
				{
					"tag": "@category",
					"value": "Number"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Parses string to `floating` number",
						"example": "P.toFloat(\"1.378998\") // = 1.378998\nP.toFloat(\"test\") // undefined\nP.toFloat(\"test\", 0) // 0",
						"parsed": [
							{
								"tag": "@description",
								"content": [
									"This function litle bit different than parseFloat. First of all it can return undefined if float parsing is unsuccessful.",
									"Regular parseFloat return `NaN` this is really misleading"
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Number"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function toFloat(data: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!toFloat:function(1)",
					"canonicalReferenceGroup": "ts-prime!toFloat"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function toFloat<T extends "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ">(data: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ", defaultValue: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!toFloat:function(2)",
					"canonicalReferenceGroup": "ts-prime!toFloat"
				}
			],
			"kind": "Function",
			"name": "toFloat",
			"canonicalReference": "ts-prime!toFloat:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!toFloat",
			"tags": [
				{
					"tag": "@category",
					"value": "Number"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Parses string to `int` number",
						"example": "P.toInt(\"1.378998\") // = 1\nP.toInt(\"test\") // undefined\nP.toInt(\"test\", 0) // 0",
						"parsed": [
							{
								"tag": "@description",
								"content": [
									"This function litle bit different than parseInt. First of all it can return undefined if int parsing is unsuccessful.",
									"Regular parseInt cant return `NaN` and this is really misleading"
								]
							},
							{
								"tag": "@param",
								"content": {
									"description": "Anything",
									"name": "data"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Number"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function toInt(data: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number | undefined"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!toInt:function(1)",
					"canonicalReferenceGroup": "ts-prime!toInt"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function toInt<T extends "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ">(data: "
						},
						{
							"kind": "Content",
							"text": "unknown"
						},
						{
							"kind": "Content",
							"text": ", defaultValue: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!toInt:function(2)",
					"canonicalReferenceGroup": "ts-prime!toInt"
				}
			],
			"kind": "Function",
			"name": "toInt",
			"canonicalReference": "ts-prime!toInt:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!toInt",
			"tags": [
				{
					"tag": "@category",
					"value": "Number"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns an array of key/values of the enumerable properties of an object.",
						"example": "P.toPairs({ a: 1, b: 2, c: 3 }) // => [['a', 1], ['b', 2], ['c', 3]]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "Any object",
									"name": "object"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.toPairs(object)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Object"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function toPairs<T extends "
						},
						{
							"kind": "Content",
							"text": "{\n    [k: string]: unknown;\n}"
						},
						{
							"kind": "Content",
							"text": ">(object: "
						},
						{
							"kind": "Content",
							"text": "T"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "ReadonlyArray",
							"canonicalReference": "!ReadonlyArray:interface"
						},
						{
							"kind": "Content",
							"text": "<[keyof T, T[keyof T]]>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!toPairs:function(1)",
					"canonicalReferenceGroup": "ts-prime!toPairs"
				}
			],
			"kind": "Function",
			"name": "toPairs",
			"canonicalReference": "ts-prime!toPairs:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!toPairs",
			"tags": [
				{
					"tag": "@category",
					"value": "Object"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Gives a single-word string description of the (native) type of a value, returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not attempt to distinguish user Object types any further, reporting them all as 'Object'.",
						"example": "P.type({}); //=> \"Object\"\nP.type(1); //=> \"Number\"\nP.type(false); //=> \"Boolean\"\nP.type('s'); //=> \"String\"\nP.type(null); //=> \"Null\"\nP.type([]); //=> \"Array\"\nP.type(/[A-z]/); //=> \"RegExp\"\nP.type(() => {}); //=> \"Function\"\nP.type(undefined); //=> \"Undefined\"",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "",
									"name": "val"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.type(obj)"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function type(val: "
						},
						{
							"kind": "Content",
							"text": "any"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!type:function(1)",
					"canonicalReferenceGroup": "ts-prime!type"
				}
			],
			"kind": "Function",
			"name": "type",
			"canonicalReference": "ts-prime!type:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!type",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns a new array containing only one copy of each element in the original list.\r\n  Elements are compared by reference using Set.\r\n  Note: In `pipe`, use `uniq()` form instead of `uniq`. Otherwise, the inferred type is lost.",
						"example": "P.uniq([1, 2, 2, 5, 1, 6, 7]) // => [1, 2, 5, 6, 7]\nP.pipe(\n[1, 2, 2, 5, 1, 6, 7], // only 4 iterations\nP.uniq(),\nP.take(3)\n) // => [1, 2, 5]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "List of items",
									"name": "array"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.uniq(array)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.pipe(array",
									"P.uniq())"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function uniq<T>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!uniq:function(1)",
					"canonicalReferenceGroup": "ts-prime!uniq"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function uniq<T>(): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!uniq:function(2)",
					"canonicalReferenceGroup": "ts-prime!uniq"
				},
				{
					"kind": "Namespace",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare namespace uniq "
						}
					],
					"canonicalReference": "ts-prime!uniq:namespace",
					"canonicalReferenceGroup": "ts-prime!uniq"
				}
			],
			"kind": "Function",
			"name": "uniq",
			"canonicalReference": "ts-prime!uniq:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!uniq",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Returns a new array containing only one copy of each element in the original list transformed by a function.\r\n  Elements are compared by reference using Set.",
						"example": "P.uniq(obj => obj.n, [{n: 1}, {n: 2}, {n: 2}, {n: 5}, {n: 1}, {n: 6}, {n: 7}]) // => [{n: 1}, {n: 2}, {n: 5}, {n: 6}, {n: 7}]\nP.pipe(\n[{n: 1}, {n: 2}, {n: 2}, {n: 5}, {n: 1}, {n: 6}, {n: 7}], // only 4 iterations\nP.uniq(obj => obj.n),\nP.take(3)\n) // => [{n: 1}, {n: 2}, {n: 5}]",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "List of items",
									"name": "array"
								}
							},
							{
								"tag": "@signature",
								"content": [
									"P.uniqBy(fn",
									"array)"
								]
							},
							{
								"tag": "@signature",
								"content": [
									"P.pipe(array",
									"P.uniqBy(fn))"
								]
							},
							{
								"tag": "@category",
								"content": [
									"Array",
									"Pipe"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function uniqBy<T, K>(array: "
						},
						{
							"kind": "Content",
							"text": "readonly T[]"
						},
						{
							"kind": "Content",
							"text": ", transformer: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => K"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!uniqBy:function(1)",
					"canonicalReferenceGroup": "ts-prime!uniqBy"
				},
				{
					"kind": "Function",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function uniqBy<T, K>(transformer: "
						},
						{
							"kind": "Content",
							"text": "(item: T) => K"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Content",
							"text": "(array: readonly T[]) => T[]"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!uniqBy:function(2)",
					"canonicalReferenceGroup": "ts-prime!uniqBy"
				}
			],
			"kind": "Function",
			"name": "uniqBy",
			"canonicalReference": "ts-prime!uniqBy:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!uniqBy",
			"tags": [
				{
					"tag": "@category",
					"value": "Array"
				},
				{
					"tag": "@category",
					"value": "Pipe"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Class",
					"comment": {
						"description": "",
						"parsed": []
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare class UnknownError extends "
						},
						{
							"kind": "Reference",
							"text": "Error",
							"canonicalReference": "!Error:interface"
						},
						{
							"kind": "Content",
							"text": " "
						}
					],
					"canonicalReference": "ts-prime!UnknownError:class",
					"canonicalReferenceGroup": "ts-prime!UnknownError"
				}
			],
			"kind": "Class",
			"name": "UnknownError",
			"canonicalReference": "ts-prime!UnknownError:class",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!UnknownError",
			"tags": []
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Generates non cryptographic UUID",
						"example": "P.uuidv4() //=> aecad060-0bb7-4567-af08-4dfe5f46d130",
						"parsed": [
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function uuidv4(): "
						},
						{
							"kind": "Content",
							"text": "string"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!uuidv4:function(1)",
					"canonicalReferenceGroup": "ts-prime!uuidv4"
				}
			],
			"kind": "Function",
			"name": "uuidv4",
			"canonicalReference": "ts-prime!uuidv4:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!uuidv4",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		},
		{
			"members": [
				{
					"kind": "Function",
					"comment": {
						"description": "Function repeats provided call until it returns not null or undefined value.\r\n  If this process exceeds `maxDurationMs` function will throw\r\n  of those function calls.",
						"example": "const result = await waitUntilDefined(() => document.body.getElementById(\"#app\"))",
						"parsed": [
							{
								"tag": "@param",
								"content": {
									"description": "The function to invoke.",
									"name": "fn"
								}
							},
							{
								"tag": "@param",
								"content": {
									"description": "Max waiting duration",
									"name": "maxDurationMs"
								}
							},
							{
								"tag": "@category",
								"content": [
									"Utility"
								]
							},
							{
								"tag": "@throws",
								"content": [
									"If if fn does not return not nil value in given time frame"
								]
							}
						]
					},
					"excerptTokens": [
						{
							"kind": "Content",
							"text": "export declare function waitUntilDefined<T>(fn: "
						},
						{
							"kind": "Content",
							"text": "() => T | undefined"
						},
						{
							"kind": "Content",
							"text": ", maxDurationMs: "
						},
						{
							"kind": "Content",
							"text": "number"
						},
						{
							"kind": "Content",
							"text": "): "
						},
						{
							"kind": "Reference",
							"text": "Promise",
							"canonicalReference": "!Promise:interface"
						},
						{
							"kind": "Content",
							"text": "<"
						},
						{
							"kind": "Reference",
							"text": "NonNullable",
							"canonicalReference": "!NonNullable:type"
						},
						{
							"kind": "Content",
							"text": "<T>>"
						},
						{
							"kind": "Content",
							"text": ";"
						}
					],
					"canonicalReference": "ts-prime!waitUntilDefined:function(1)",
					"canonicalReferenceGroup": "ts-prime!waitUntilDefined"
				}
			],
			"kind": "Function",
			"name": "waitUntilDefined",
			"canonicalReference": "ts-prime!waitUntilDefined:function(1)",
			"package": "ts-prime",
			"canonicalReferenceGroup": "ts-prime!waitUntilDefined",
			"tags": [
				{
					"tag": "@category",
					"value": "Utility"
				}
			]
		}
	],
	"articles": {
		"readme": "![alt text](https://digimuza.github.io/ts-prime/logo.svg \"ts-prime\")\n### The utility library designed <span style=\"color: #1890ff\">for TypeScript<span>.\n\n[![Build Status](https://travis-ci.org/remeda/remeda.svg?branch=master)](https://travis-ci.org/remeda/remeda)\n[![npm module](https://badge.fury.io/js/ts-prime.svg)](https://www.npmjs.org/package/ts-prime)\n[![dependencies](https://david-dm.org/digimuza/ts-prime/status.svg)](https://david-dm.org/digimuza/ts-prime)\n\n## Installation\n\n```bash\nnpm i ts-prime\n```\n\n```bash\nyarn add ts-prime\n```\n\nThen in .js or .ts\n\n```typescript\nimport * as P from \"ts-prime\"; // tree-shaking supported!\n```\n\n## Why ts-prime?\n\nThere are no universal utility libraries that fits my development need. Most of the development libraries did had function that I needed in day to day development.\n\n## ts-prime Design Goals\n\n1. The usage must be programmer-friendly, and that's more important than following the XYZ paradigm strictly.\n2. Manual annotation should never be required, and proper typings should infer everything. The only exception is the first function in `createPipe`.\n3. E6 polyfill is required. Core methods are reused, and data structure (like Map/Set) are not re-implemented.\n4. The implementation of each function should be as minimal as possible. Tree-shaking is supported by default. (Do you know that `lodash.keyBy` has 14KB after minification?)\n5. All functions are immutable, and there are no side-effects.\n6. Fixed number of arguments.\n7. Designed with typescript limitations in mind\n\nMIT"
	}
}